Char.IsNumber(Char)  //method to check whether the specified Unicode character matches number or not

using System;
class GFG {
 
    // Main Method
    static public void Main()
    {
 
        // Declaration of data type
        bool result;
 
        // checking if 5 is a
        // number or not
        char ch1 = '5';
        result = Char.IsNumber(ch1);
        Console.WriteLine(result);    //True
 
        // checking if 'c' is a
        // number or not
        char ch2 = 'c';
        result = Char.IsNumber(ch2);
        Console.WriteLine(result);    //False
    }
}

Char.IsNumber(String, Int32) //method is used to check whether the specified string at specified position matches with any number or not.
 
using System;
class GFG {
 
    // Main Method
    static public void Main()
    {
 
        // Declaration of data type
        bool result;
 
        // checking for number in a
        // string at a desired position
        string str1 = "GeeksforGeeks";
        result = Char.IsNumber(str1, 2);
        Console.WriteLine(result);        //False
 
        // checking for number in a
        // string at a desired position
        string str2 = "geeks5forgeeks";
        result = Char.IsNumber(str2, 5);  //True
        Console.WriteLine(result);
    }
}

C# Serialization & Deserialization
//Serialization is a concept in which C# class objects are written or serialized to files.
//example C# class Tutorial having 2 properties ID and Tutorial name
//Serializing can be used to directly write the data properties of the Tutorial class to a file.
//Deserialization is used to read the data from the file and construct the Tutorial object again.
using System;
using System.IO;
using System.Linq;
using System.Runtime.Serialization;
using System.Runtime.Serialization.Formatters.Binary;
using System.Text;
using System.Threading.Tasks;
namespace DemoApplication
{
  [Serializable]
  class Tutorial
  {
  public int ID;
  public String Name;
   static void Main(string[] args)
   {
    Tutorial obj = new Tutorial();
    obj.ID = 1;
    obj.Name = ".Net";
 
    //create the file stream
    IFormatter formatter = new BinaryFormatter();
    Stream stream = new FileStream(@"E:\ExampleNew.txt",FileMode.Create,FileAccess.Write);

    //serialize the object
    formatter.Serialize(stream, obj);
    stream.Close();

    //create the file stream
    stream = new FileStream(@"E:\ExampleNew.txt",FileMode.Open,FileAccess.Read);
    
    //deserialize the object
    Tutorial objnew = (Tutorial)formatter.Deserialize(stream);

    //write data to the console
    Console.WriteLine(objnew.ID);
    Console.WriteLine(objnew.Name);

    Console.ReadKey();
  }
 }
}

# Questions
==================
1. What are the differences between ref and out keywords?

A. C# ref keywords pass arguments by reference and not value. To use the ‘ref’ keyword, you need to explicitly mention ‘ref’. 

void Method(ref int refArgument)
{
   refArgument = refArgument + 10;
}
int number = 1;
Method(ref number);
Console.WriteLine(number);
// Output: 11

C# out keywords pass arguments within methods and functions. 
‘out’ keyword is used to pass arguments in a method as a reference to return multiple values. 
Although it is the same as the ref keyword, the ref keyword needs to be initialised before it is passed. 
Here, The out and ref keywords are useful when we want to return a value in the same variables that are passed as an argument. 

public static string GetNextFeature(ref int id)  
{  
   string returnText = "Next-" + id.ToString();  
   id += 1;  
   return returnText;  
}  
public static string GetNextFeature(out int id)  
{  
   id = 1;  
   string returnText = "Next-" + id.ToString();  
   return returnText;  
}   

2. What are extension methods in C#?

A. Extension methods help to add new methods to the existing ones. 
The methods that are added are static. 
At times, when you want to add methods to an existing class but don’t perceive the right to modify that class or don’t hold the rights, 
you can create a new static class containing the new methods.
Once the extended methods are declared, bind this class with the existing one and see the methods will be added to the existing one.

// C# program to illustrate the concept
// of the extension methods
using System;
 
namespace ExtensionMethod {
static class NewMethodClass {
 
   // Method 4
   public static void M4(this Scaler s)
   {
       Console.WriteLine("Method Name: M4");
   }
 
   // Method 5
   public static void M5(this Scaler s, string str)
   {
       Console.WriteLine(str);
   }
}
 
// Now we create a new class in which
// Scaler class access all the five methods
public class IB {
 
   // Main Method
   public static void Main(string[] args)
   {
       Scaler s = new Scaler();
       s.M1();
       s.M2();
       s.M3();
       s.M4();
       s.M5("Method Name: M5");
   }
}
}
Output:

Method Name: M1

Method Name: M2

Method Name: M3

Method Name: M4

Method Name: M5

3. What are Generics in C#?

A. In C# collections, defining any kind of object is termed okay which compromises C#’s basic rule of type-safety. 
Therefore, generics were included to type-safe the code by allowing re-use of the data processing algorithms. 
Generics in C# mean not linked to any specific data type. Generics reduce the load of using boxing, unboxing, and typecasting objects.
Generics are always defined inside angular brackets <>. To create a generic class, this syntax is used:

GenericList<float> list1 = new GenericList<float>();
GenericList<Features> list2 = new GenericList<Features>();
GenericList<Struct> list3 = new GenericList<Struct>();

Here, GenericList<float> is a generic class. 
In each of these instances of GenericList<T>, every occurrence of T in the class is substituted at run time with the type argument. 
By substituting the T, we have created three different type-safe using the same class. 

4. What is the difference between an Array and ArrayList in C#?

A. An array is a collection of similar variables clubbed together under one common name. 
While ArrayList is a collection of objects that can be indexed individually.
With ArrayList you can access a number of features like dynamic memory allocation, adding, searching, and sorting items in the ArrayList. 

=>When declaring an array the size of the items is fixed therefore, the memory allocation is fixed. But with ArrayList, it can be increased or decreased dynamically.
=>Array belongs to system.array namespace while ArrayList belongs to the system.collection namespace.
=>All items in an array are of the same datatype while all the items in an ArrayList can be of the same or different data types.
=>While arrays cannot accept null, ArrayList can accept null values.

For ex.:

// C# program to illustrate the ArrayList
using System;
using System.Collections;
 
class IB {
 
   // Main Method
   public static void Main(string[] args)
   {
 
       // Create a list of strings
       ArrayList al = new ArrayList();
       al.Add("Bruno");
       al.Add("Husky");
       al.Add(10);
       al.Add(10.10);
 
       // Iterate list element using foreach loop
       foreach(var names in al)
       {
           Console.WriteLine(names);
       }
   }
}

5. What is inheritance? Does C# support multiple inheritance?

A. Inheritance means acquiring some of the properties from a master class.     A     B
                                                                                \   /
                                                                                  C
Here, class C can inherit properties from Class A and Class B. But, C# doesn’t support multiple inheritances. 
Instead, you can use interfaces to inherit the properties using the class name in the signature.

// C# program to illustrate
// multiple class inheritance
using System;
using System.Collections;

// Parent class 1
class Scaler {

  // Providing the implementation
  // of features() method
  public void features()
  {

      // Creating ArrayList
      ArrayList My_features= new ArrayList();

      // Adding elements in the
      // My_features ArrayList
      My_features.Add("Abstraction");
      My_features.Add("Encapsulation");
      My_features.Add("Inheritance");

      Console.WriteLine("Features provided by OOPS:");
      foreach(var elements in My_features)
      {
          Console.WriteLine(elements);
      }
  }
}

// Parent class 2
class Scaler2 :Scaler{

  // Providing the implementation
  // of courses() method
  public void languages()
  {

      // Creating ArrayList
      ArrayList My_features = new ArrayList();

      // Adding elements in the
      // My_features ArrayList
      My_features.Add("C++");
      My_features.Add("C#");
      My_features.Add("JScript");
     

      Console.WriteLine("\nLanguages that use OOPS concepts:");
      foreach(var elements in My_features)
      {
          Console.WriteLine(elements);
      }
  }
}

// Child class
class ScalertoScaler : Scaler2 {
}

public class Scaler1 {

  // Main method
  static public void Main()
  {

      // Creating object of ScalertoScaler class
      ScalertoScaler obj = new ScalertoScaler();
      obj.features();
      obj.languages();
  }
}

6. What is Boxing and Unboxing in C#?

A. Boxing: Boxing converts value type (int, char, etc.) to reference type (object) which is an implicit conversion process using object value. 
int num = 23; // 23 will assigned to num
Object Obj = num; // Boxing

Unboxing: Unboxing converts reference type (object) to value type (int, char, etc.) using an explicit conversion process. 
int num = 23;         // value type is int and assigned value 23
Object Obj = num;    // Boxing
int i = (int)Obj;    // Unboxing

7. What are Properties in C#?

A. Properties in C# are public members of a class where they provide the ability to access private members of a class. 
The basic principle of encapsulation lets you hide some sensitive properties from the users by making the variables private. 
The private members are not accessible otherwise in a class. 
Therefore, by using properties in C# you can easily access the private members and set their values. 

The values can be easily assigned using get and set methods, also known as accessors.
While the get method extracts the value, the set method assigns the value to the variables.

8. What are partial classes in C#?

A. Partial classes implement the functionality of a single class into multiple files. 
These multiple files are combined into one during compile time. The partial class can be created using the partial keyword. 

public partial Clas_name  
{
       // code
}

Partial Classes can be created in the same namespace. It isn't possible to create a partial class in a different namespace. 
So use the “partial” keyword with all the class names that you want to bind together with the same name of a class in the same namespace.

partial class Class1{
      public void function1()
      {
        Console.WriteLine("function 1");
      }
}
partial class Class1{
      public void function2()
      {
        Console.WriteLine("function 2");
      }
}

class Program{
      static void Main(string [] args)
      {
        Class1 obj = new Class1();
        obj.function1();
        obj.function2();
      }
}

You can easily split the functionalities of methods, interfaces, or structures into multiple files. 
You can even add nested partial classes. 

9.  What is the difference between late binding and early binding in C#?

A. Late binding and early binding are examples of one of the primary concepts of OOPS: Polymorphism. 

For ex: one function calculateBill() will calculate bills of premium customers, basic customers, and semi-premium customers based on their policies differently.
The calculation for all the customer objects is done differently using the same function which is called polymorphism. 

When an object is assigned to an object variable in C#, the .NET framework performs the binding. 

When the binding function happens at compile-time, it is called early binding. 
It investigates and checks the methods and properties of the static objects. 
With early binding, the number of run-time errors decreases substantially and it executes pretty quickly. 

But when the binding happens at runtime, it is called late binding. 
Late binding happens when the objects are dynamic (decided based on the data they hold) at run-time. 
It is slower as it looks through during run-time.

10. Arrays in C#

A. A few pointers for arrays in C#:

-The memory allocation is DYNAMIC.
-Arrays in C# are treated as objects.
-The length of the array is easy to find by detecting the number of members in the array.
-The members in the array are ordered and begin with the index value=0.
-The array types are reference types derived from the base array type.
-Syntax: < Data Type > [ ] < Name_Array >

11. What are Indexers in C#?

A. Indexers are called smart arrays that allow access to a member variable. 
Indexers allow member variables using the features of an array. They are created using the Indexer keyword. 
Indexers are not static members. 

For ex. Here the indexer is defined the same way.

<return type> this[<parameter type> index]
{
   get{
       // return the value from the specified index of an internal collection
   }
   set{
       // set values at the specified index in an internal collection
   }
}

12. Difference between the Equality Operator (==) and Equals() Method in C#?

A. Although both are used to compare two objects by value, still they both are used differently. 

For ex.:

int x = 10;
int y = 10;
Console.WriteLine( x == y);
Console.WriteLine(x.Equals(y));
Output:
True
True

Equality operator (==) is a reference type which means that if equality operator is used, it will return true only if both the references point to the same object.  

Equals() method: Equals method is used to compare the values carried by the objects. 
int x=10, int y=10. If x==y is compared then, the values carried by x and y are compared which is equal and therefore they return true. 

Equality operator: Compares by reference

Equals(): Compares by value 

13. What are the different ways in which a method can be Overloaded in C#?

A. Overloading means when a method has the same name but carries different values to use in a different context.
Only the main() method cannot be overloaded.

In order to overload methods in C#, 

=>Change the number of parameters in a method, or
=>Change the order of parameters in a method, or
=>Use different data types for parameters
In these ways, you can overload a method multiple times.
For ex.

public class Area {
   public double area(double x) {
       double area = x * x;
       return area;
   }
   public double area(double a, double b) {
       double area = a * b;
       return area;
   }
}

14.  What is Reflection in C#?

A. Reflection in C# extracts metadata from the datatypes during runtime. 

To add reflection in the .NET framework, simply use System.Refelction namespace in your program to retrieve the type which can be anything from:

Assembly
Module
Enum
MethodInfo
ConstructorInfo
MemberInfo
ParameterInfo
Type
FieldInfo
EventInfo
PropertyInfo

15. What is the difference between constant and readonly in C#?

A. A const keyword in C# is used to declare a constant field throughout the program. 
That means once a variable has been declared const, its value cannot be changed throughout the program. 

In C#, a constant is a number, string, null reference, or boolean values. 

For ex:

class IB {
 
   // Constant fields
   public const int xvar = 20;
   public const string str = "InterviewBit";
 
   // Main method
   static public void Main()
   {
 
       // Display the value of Constant fields
       Console.WriteLine("The value of xvar: {0}", xvar);
       Console.WriteLine("The value of str: {0}", str);
   }
}
Output:
The value of xvar is 20.
The value of string is Interview Bit

On the other hand, with readonly keyword, you can assign the variable 
only when it is declared or in a constructor of the same class in which it is declared. 

Ex:

public readonly int xvar1;
   public readonly int yvar2;
 
   // Values of the readonly 
   // variables are assigned
   // Using constructor
   public IB(int b, int c)
   {
 
       xvar1 = b;
       yvar2 = c;
       Console.WriteLine("The value of xvar1 {0}, "+
                       "and yvar2 {1}", xvar1, yvar2);
   }
 
   // Main method
   static public void Main()
   {
     IB obj1 = new IB(50, 60);
   }
}

Output:
The value of xvar1 is 50, and yvar2 is 60

Constants are static by default while readonly should have a value assigned when the constructor is declared. 
Constants can be declared within functions while readonly modifiers can be used with reference types. 

16. What is the difference between String and StringBuilder in C#?

A. The major difference between String and StringBuilder is that String objects are immutable while 
StringBuilder creates a mutable string of characters. StringBuilder will make the changes to the existing object rather than creating a new object.

StringBuilder simplifies the entire process of making changes to the existing string object. 
Since the String class is immutable, it is costlier to create a new object every time we need to make a change. 
So, the StringBuilder class comes into picture which can be evoked using the System.Text namespace.

In case, a string object will not change throughout the entire program, then use String class or else StringBuilder. 

For ex:

string s = string.Empty; 
for (i = 0; i < 1000; i++) 
  { 
    s += i.ToString() + " "; 
  }
Here, you’ll need to create 2001 objects out of which 2000 will be of no use.

The same can be applied using StringBuilder:

StringBuilder sb = new StringBuilder(); 
for (i = 0; i < 1000; i++) 
 { 
   sb.Append(i); sb.Append(' '); 
 }

By using StringBuilder here, you also de-stress the memory allocator.

17. What is the difference between Interface and Abstract Class in C#?

A. A class can implement any number of interfaces but a subclass can at most use only one abstract class.
An abstract class can have non-abstract methods (concrete methods) while in case of interface, all the methods have to be abstract.
An abstract class can declare or use any variables while an interface is not allowed to do so.
In an abstract class, all data members or functions are private by default while in an interface all are public, we can’t change them manually.
In an abstract class, we need to use abstract keywords to declare abstract methods, while in an interface we don’t need to use that.
An abstract class can’t be used for multiple inheritance while the interface can be used as multiple inheritance.
An abstract class use constructor while in an interface we don’t have any type of constructor.

18. What is the difference between the dispose and finalize methods in C#?

A. Finalize
Finalize is used to free unmanaged resources that are not in use, like files, database connections in the application domain and more.
These are resources held by an object before that object is destroyed.
In the Internal process, it is called by Garbage Collector and can’t be called manual by user code or any service.
Finalize belongs to System.Object class.
Implement it when you have unmanaged resources in your code, and make sure that these resources are freed when the Garbage collection happens.

Dispose
Dispose is also used to free unmanaged resources that are not in use like files, database connections in the Application domain at any time.
Dispose is explicitly called by manual user code.
If we need to use the dispose method, we must implement that class via IDisposable interface.
It belongs to IDisposable interface.
Implement this when you are writing a custom class that will be used by other users.

19. What are delegates in C# and the uses of delegates?

A. A Delegate is an abstraction of one or more function pointers (as existed in C++; the explanation about this is out of the scope of this article). 
The .NET has implemented the concept of function pointers in the form of delegates. 
With delegates, you can treat a function as data. 
Delegates allow functions to be passed as parameters, returned from a function as a value and stored in an array. 

Delegates have the following characteristics:
-Delegates are derived from the System.MulticastDelegate class.
-They have a signature and a return type. A function that is added to delegates must be compatible with this signature.
-Delegates can point to either static or instance methods.
-Once a delegate object has been created, it may dynamically invoke the methods it points to at runtime.
-Delegates can call methods synchronously and asynchronously.

The delegate contains a couple of useful fields. The first one holds a reference to an object, and the second holds a method pointer.
When you invoke the delegate, the instance method is called on the contained reference. 
However, if the object reference is null then the runtime understands this to mean that the method is a static method. 
Moreover, invoking a delegate syntactically is the exact same as calling a regular function. 
Therefore, delegates are perfect for implementing callbacks.
 
Why Do We Need Delegates?
 
Historically, the Windows API made frequent use of C-style function pointers to create callback functions. 
Using a callback, programmers were able to configure one function to report back to another function in the application. 
So the objective of using a callback is to handle button-clicking, menu-selection, and mouse-moving activities. 
But the problem with this traditional approach is that the callback functions were not type-safe. 
In the .NET framework, callbacks are still possible using delegates with a more efficient approach.

Delegates maintain three important pieces of information:
-The parameters of the method.
-The address of the method it calls.
-The return type of the method.

A delegate is a solution for situations in which you want to pass methods around to other methods. 
You are so accustomed to passing data to methods as parameters that the idea of passing methods as an argument instead of data might sound a little strange. 
However, there are cases in which you have a method that does something, for instance, invoking some other method.
You do not know at compile time what this second method is.
That information is available only at runtime, hence Delegates are the device to overcome such complications.

Delegates Sample Program

The delegate implementation can cause a great deal of confusion when encountered the first time. 
Thus, it is a great idea to get an understanding by creating this sample program as: 
using System;
namespace Delegates  
{  
    // Delegate Definition  
    public delegate int operation(int x, int y);  
         
    class Program  
    {  
        // Method that is passes as an Argument  
        // It has same signature as Delegates   
        static int Addition(int a, int b)  
        {  
            return a + b;  
        }  
  
        static void Main(string[] args)  
        {  
            // Delegate instantiation  
            operation obj = new operation(Program.Addition);  
   
            // output  
            Console.WriteLine("Addition is={0}",obj(23,27));   
            Console.ReadLine();    
        }  
    }  
}  
Here, we are defining the delegate as a delegate type. 
The important point to remember is that the signature of the function reference by the delegate must match the delegate signature as:

// Delegate Definition  
public delegate int operation(int x, int y);  
Notice the format of the operation delegate type declaration; it specifies that the operation object can permit any method taking two integers and returning an integer.

When you want to insert the target methods to a given delegate object, simply pass in the name of the method to the delegate constructor as: 
// Delegate instantiation  
operation obj = new operation(Program.Addition);  

At this point, you are able to invoke the member pointed to using a direct function invocation as:
Console.WriteLine("Addition is={0}",obj(23,27));   
Finally, when the delegate is no longer required, set the delegate instance to null.

Recall that .NET delegates are type-safe. Therefore, if you attempt to pass a delegate a method that does not match the signature pattern,
the .NET will report a compile-time error.

20. What is IEnumerable<> in C#?

A. IEnumerable is the parent interface for all non-generic collections in System.Collections namespace 
like ArrayList, HastTable etc. that can be enumerated. 
For the generic version of this interface as 
IEnumerable<T> which a parent interface of all generic collections class in System.Collections.Generic namespace 
like List<> and more.

In System.Collections.Generic.IEnumerable<T> have only a single method which is GetEnumerator() that returns an IEnumerator. 
IEnumerator provides the power to iterate through the collection by exposing a Current property and Move Next and Reset methods
if we don’t have this interface as a parent so we can’t use iteration by foreach loop or can’t use that class object in our LINQ query.
 
21. 
