Char.IsNumber(Char)  //method to check whether the specified Unicode character matches number or not

using System;
class GFG {
 
    // Main Method
    static public void Main()
    {
 
        // Declaration of data type
        bool result;
 
        // checking if 5 is a
        // number or not
        char ch1 = '5';
        result = Char.IsNumber(ch1);
        Console.WriteLine(result);    //True
 
        // checking if 'c' is a
        // number or not
        char ch2 = 'c';
        result = Char.IsNumber(ch2);
        Console.WriteLine(result);    //False
    }
}

Char.IsNumber(String, Int32) //method is used to check whether the specified string at specified position matches with any number or not.
 
using System;
class GFG {
 
    // Main Method
    static public void Main()
    {
 
        // Declaration of data type
        bool result;
 
        // checking for number in a
        // string at a desired position
        string str1 = "GeeksforGeeks";
        result = Char.IsNumber(str1, 2);
        Console.WriteLine(result);        //False
 
        // checking for number in a
        // string at a desired position
        string str2 = "geeks5forgeeks";
        result = Char.IsNumber(str2, 5);  //True
        Console.WriteLine(result);
    }
}

C# Serialization & Deserialization
//Serialization is a concept in which C# class objects are written or serialized to files.
//example C# class Tutorial having 2 properties ID and Tutorial name
//Serializing can be used to directly write the data properties of the Tutorial class to a file.
//Deserialization is used to read the data from the file and construct the Tutorial object again.
using System;
using System.IO;
using System.Linq;
using System.Runtime.Serialization;
using System.Runtime.Serialization.Formatters.Binary;
using System.Text;
using System.Threading.Tasks;
namespace DemoApplication
{
  [Serializable]
  class Tutorial
  {
  public int ID;
  public String Name;
   static void Main(string[] args)
   {
    Tutorial obj = new Tutorial();
    obj.ID = 1;
    obj.Name = ".Net";
 
    //create the file stream
    IFormatter formatter = new BinaryFormatter();
    Stream stream = new FileStream(@"E:\ExampleNew.txt",FileMode.Create,FileAccess.Write);

    //serialize the object
    formatter.Serialize(stream, obj);
    stream.Close();

    //create the file stream
    stream = new FileStream(@"E:\ExampleNew.txt",FileMode.Open,FileAccess.Read);
    
    //deserialize the object
    Tutorial objnew = (Tutorial)formatter.Deserialize(stream);

    //write data to the console
    Console.WriteLine(objnew.ID);
    Console.WriteLine(objnew.Name);

    Console.ReadKey();
  }
 }
}

# Questions
==================
1. What are the differences between ref and out keywords?

A. C# ref keywords pass arguments by reference and not value. To use the ‘ref’ keyword, you need to explicitly mention ‘ref’. 

void Method(ref int refArgument)
{
   refArgument = refArgument + 10;
}
int number = 1;
Method(ref number);
Console.WriteLine(number);
// Output: 11

C# out keywords pass arguments within methods and functions. 
‘out’ keyword is used to pass arguments in a method as a reference to return multiple values. 
Although it is the same as the ref keyword, the ref keyword needs to be initialised before it is passed. 
Here, The out and ref keywords are useful when we want to return a value in the same variables that are passed as an argument. 

public static string GetNextFeature(ref int id)  
{  
   string returnText = "Next-" + id.ToString();  
   id += 1;  
   return returnText;  
}  
public static string GetNextFeature(out int id)  
{  
   id = 1;  
   string returnText = "Next-" + id.ToString();  
   return returnText;  
}   

2. What are extension methods in C#?

A. Extension methods help to add new methods to the existing ones. 
The methods that are added are static. 
At times, when you want to add methods to an existing class but don’t perceive the right to modify that class or don’t hold the rights, 
you can create a new static class containing the new methods.
Once the extended methods are declared, bind this class with the existing one and see the methods will be added to the existing one.

// C# program to illustrate the concept
// of the extension methods
using System;
 
namespace ExtensionMethod {
static class NewMethodClass {
 
   // Method 4
   public static void M4(this Scaler s)
   {
       Console.WriteLine("Method Name: M4");
   }
 
   // Method 5
   public static void M5(this Scaler s, string str)
   {
       Console.WriteLine(str);
   }
}
 
// Now we create a new class in which
// Scaler class access all the five methods
public class IB {
 
   // Main Method
   public static void Main(string[] args)
   {
       Scaler s = new Scaler();
       s.M1();
       s.M2();
       s.M3();
       s.M4();
       s.M5("Method Name: M5");
   }
}
}
Output:

Method Name: M1

Method Name: M2

Method Name: M3

Method Name: M4

Method Name: M5

3. What are Generics in C#?

A. In C# collections, defining any kind of object is termed okay which compromises C#’s basic rule of type-safety. 
Therefore, generics were included to type-safe the code by allowing re-use of the data processing algorithms. 
Generics in C# mean not linked to any specific data type. Generics reduce the load of using boxing, unboxing, and typecasting objects.
Generics are always defined inside angular brackets <>. To create a generic class, this syntax is used:

GenericList<float> list1 = new GenericList<float>();
GenericList<Features> list2 = new GenericList<Features>();
GenericList<Struct> list3 = new GenericList<Struct>();

Here, GenericList<float> is a generic class. 
In each of these instances of GenericList<T>, every occurrence of T in the class is substituted at run time with the type argument. 
By substituting the T, we have created three different type-safe using the same class. 

4. What is the difference between an Array and ArrayList in C#?

A. An array is a collection of similar variables clubbed together under one common name. 
While ArrayList is a collection of objects that can be indexed individually.
With ArrayList you can access a number of features like dynamic memory allocation, adding, searching, and sorting items in the ArrayList. 

=>When declaring an array the size of the items is fixed therefore, the memory allocation is fixed. But with ArrayList, it can be increased or decreased dynamically.
=>Array belongs to system.array namespace while ArrayList belongs to the system.collection namespace.
=>All items in an array are of the same datatype while all the items in an ArrayList can be of the same or different data types.
=>While arrays cannot accept null, ArrayList can accept null values.

For ex.:

// C# program to illustrate the ArrayList
using System;
using System.Collections;
 
class IB {
 
   // Main Method
   public static void Main(string[] args)
   {
 
       // Create a list of strings
       ArrayList al = new ArrayList();
       al.Add("Bruno");
       al.Add("Husky");
       al.Add(10);
       al.Add(10.10);
 
       // Iterate list element using foreach loop
       foreach(var names in al)
       {
           Console.WriteLine(names);
       }
   }
}

5. What is inheritance? Does C# support multiple inheritance?

A. Inheritance means acquiring some of the properties from a master class.     A     B
                                                                                \   /
                                                                                  C
Here, class C can inherit properties from Class A and Class B. But, C# doesn’t support multiple inheritances. 
Instead, you can use interfaces to inherit the properties using the class name in the signature.

// C# program to illustrate
// multiple class inheritance
using System;
using System.Collections;

// Parent class 1
class Scaler {

  // Providing the implementation
  // of features() method
  public void features()
  {

      // Creating ArrayList
      ArrayList My_features= new ArrayList();

      // Adding elements in the
      // My_features ArrayList
      My_features.Add("Abstraction");
      My_features.Add("Encapsulation");
      My_features.Add("Inheritance");

      Console.WriteLine("Features provided by OOPS:");
      foreach(var elements in My_features)
      {
          Console.WriteLine(elements);
      }
  }
}

// Parent class 2
class Scaler2 :Scaler{

  // Providing the implementation
  // of courses() method
  public void languages()
  {

      // Creating ArrayList
      ArrayList My_features = new ArrayList();

      // Adding elements in the
      // My_features ArrayList
      My_features.Add("C++");
      My_features.Add("C#");
      My_features.Add("JScript");
     

      Console.WriteLine("\nLanguages that use OOPS concepts:");
      foreach(var elements in My_features)
      {
          Console.WriteLine(elements);
      }
  }
}

// Child class
class ScalertoScaler : Scaler2 {
}

public class Scaler1 {

  // Main method
  static public void Main()
  {

      // Creating object of ScalertoScaler class
      ScalertoScaler obj = new ScalertoScaler();
      obj.features();
      obj.languages();
  }
}

6. What is Boxing and Unboxing in C#?

A. Boxing: Boxing converts value type (int, char, etc.) to reference type (object) which is an implicit conversion process using object value. 
int num = 23; // 23 will assigned to num
Object Obj = num; // Boxing

Unboxing: Unboxing converts reference type (object) to value type (int, char, etc.) using an explicit conversion process. 
int num = 23;         // value type is int and assigned value 23
Object Obj = num;    // Boxing
int i = (int)Obj;    // Unboxing

7. What are Properties in C#?

A. Properties in C# are public members of a class where they provide the ability to access private members of a class. 
The basic principle of encapsulation lets you hide some sensitive properties from the users by making the variables private. 
The private members are not accessible otherwise in a class. 
Therefore, by using properties in C# you can easily access the private members and set their values. 

The values can be easily assigned using get and set methods, also known as accessors.
While the get method extracts the value, the set method assigns the value to the variables.

8. What are partial classes in C#?

A. Partial classes implement the functionality of a single class into multiple files. 
These multiple files are combined into one during compile time. The partial class can be created using the partial keyword. 

public partial Clas_name  
{
       // code
}

Partial Classes can be created in the same namespace. It isn't possible to create a partial class in a different namespace. 
So use the “partial” keyword with all the class names that you want to bind together with the same name of a class in the same namespace.

partial class Class1{
      public void function1()
      {
        Console.WriteLine("function 1");
      }
}
partial class Class1{
      public void function2()
      {
        Console.WriteLine("function 2");
      }
}

class Program{
      static void Main(string [] args)
      {
        Class1 obj = new Class1();
        obj.function1();
        obj.function2();
      }
}

You can easily split the functionalities of methods, interfaces, or structures into multiple files. 
You can even add nested partial classes. 

9.  What is the difference between late binding and early binding in C#?

A. Late binding and early binding are examples of one of the primary concepts of OOPS: Polymorphism. 

For ex: one function calculateBill() will calculate bills of premium customers, basic customers, and semi-premium customers based on their policies differently.
The calculation for all the customer objects is done differently using the same function which is called polymorphism. 

When an object is assigned to an object variable in C#, the .NET framework performs the binding. 

When the binding function happens at compile-time, it is called early binding. 
It investigates and checks the methods and properties of the static objects. 
With early binding, the number of run-time errors decreases substantially and it executes pretty quickly. 

But when the binding happens at runtime, it is called late binding. 
Late binding happens when the objects are dynamic (decided based on the data they hold) at run-time. 
It is slower as it looks through during run-time.

10. Arrays in C#

A. A few pointers for arrays in C#:

-The memory allocation is DYNAMIC.
-Arrays in C# are treated as objects.
-The length of the array is easy to find by detecting the number of members in the array.
-The members in the array are ordered and begin with the index value=0.
-The array types are reference types derived from the base array type.
-Syntax: < Data Type > [ ] < Name_Array >

11. What are Indexers in C#?

A. Indexers are called smart arrays that allow access to a member variable. 
Indexers allow member variables using the features of an array. They are created using the Indexer keyword. 
Indexers are not static members. 

For ex. Here the indexer is defined the same way.

<return type> this[<parameter type> index]
{
   get{
       // return the value from the specified index of an internal collection
   }
   set{
       // set values at the specified index in an internal collection
   }
}

12. Difference between the Equality Operator (==) and Equals() Method in C#?

A. Although both are used to compare two objects by value, still they both are used differently. 

For ex.:

int x = 10;
int y = 10;
Console.WriteLine( x == y);
Console.WriteLine(x.Equals(y));
Output:
True
True

Equality operator (==) is a reference type which means that if equality operator is used, it will return true only if both the references point to the same object.  

Equals() method: Equals method is used to compare the values carried by the objects. 
int x=10, int y=10. If x==y is compared then, the values carried by x and y are compared which is equal and therefore they return true. 

Equality operator: Compares by reference

Equals(): Compares by value 

13. What are the different ways in which a method can be Overloaded in C#?

A. Overloading means when a method has the same name but carries different values to use in a different context.
Only the main() method cannot be overloaded.

In order to overload methods in C#, 

=>Change the number of parameters in a method, or
=>Change the order of parameters in a method, or
=>Use different data types for parameters
In these ways, you can overload a method multiple times.
For ex.

public class Area {
   public double area(double x) {
       double area = x * x;
       return area;
   }
   public double area(double a, double b) {
       double area = a * b;
       return area;
   }
}

14.  What is Reflection in C#?

A. Reflection in C# extracts metadata from the datatypes during runtime. 

To add reflection in the .NET framework, simply use System.Refelction namespace in your program to retrieve the type which can be anything from:

Assembly
Module
Enum
MethodInfo
ConstructorInfo
MemberInfo
ParameterInfo
Type
FieldInfo
EventInfo
PropertyInfo

15. What is the difference between constant and readonly in C#?

A. A const keyword in C# is used to declare a constant field throughout the program. 
That means once a variable has been declared const, its value cannot be changed throughout the program. 

In C#, a constant is a number, string, null reference, or boolean values. 

For ex:

class IB {
 
   // Constant fields
   public const int xvar = 20;
   public const string str = "InterviewBit";
 
   // Main method
   static public void Main()
   {
 
       // Display the value of Constant fields
       Console.WriteLine("The value of xvar: {0}", xvar);
       Console.WriteLine("The value of str: {0}", str);
   }
}
Output:
The value of xvar is 20.
The value of string is Interview Bit

On the other hand, with readonly keyword, you can assign the variable 
only when it is declared or in a constructor of the same class in which it is declared. 

Ex:

public readonly int xvar1;
   public readonly int yvar2;
 
   // Values of the readonly 
   // variables are assigned
   // Using constructor
   public IB(int b, int c)
   {
 
       xvar1 = b;
       yvar2 = c;
       Console.WriteLine("The value of xvar1 {0}, "+
                       "and yvar2 {1}", xvar1, yvar2);
   }
 
   // Main method
   static public void Main()
   {
     IB obj1 = new IB(50, 60);
   }
}

Output:
The value of xvar1 is 50, and yvar2 is 60

Constants are static by default while readonly should have a value assigned when the constructor is declared. 
Constants can be declared within functions while readonly modifiers can be used with reference types. 

16. What is the difference between String and StringBuilder in C#?

A. The major difference between String and StringBuilder is that String objects are immutable while 
StringBuilder creates a mutable string of characters. StringBuilder will make the changes to the existing object rather than creating a new object.

StringBuilder simplifies the entire process of making changes to the existing string object. 
Since the String class is immutable, it is costlier to create a new object every time we need to make a change. 
So, the StringBuilder class comes into picture which can be evoked using the System.Text namespace.

In case, a string object will not change throughout the entire program, then use String class or else StringBuilder. 

For ex:

string s = string.Empty; 
for (i = 0; i < 1000; i++) 
  { 
    s += i.ToString() + " "; 
  }
Here, you’ll need to create 2001 objects out of which 2000 will be of no use.

The same can be applied using StringBuilder:

StringBuilder sb = new StringBuilder(); 
for (i = 0; i < 1000; i++) 
 { 
   sb.Append(i); sb.Append(' '); 
 }

By using StringBuilder here, you also de-stress the memory allocator.

17. What is the difference between Interface and Abstract Class in C#?

A. A class can implement any number of interfaces but a subclass can at most use only one abstract class.
An abstract class can have non-abstract methods (concrete methods) while in case of interface, all the methods have to be abstract.
An abstract class can declare or use any variables while an interface is not allowed to do so.
In an abstract class, all data members or functions are private by default while in an interface all are public, we can’t change them manually.
In an abstract class, we need to use abstract keywords to declare abstract methods, while in an interface we don’t need to use that.
An abstract class can’t be used for multiple inheritance while the interface can be used as multiple inheritance.
An abstract class use constructor while in an interface we don’t have any type of constructor.

18. What is the difference between the dispose and finalize methods in C#?

A. Finalize
Finalize is used to free unmanaged resources that are not in use, like files, database connections in the application domain and more.
These are resources held by an object before that object is destroyed.
In the Internal process, it is called by Garbage Collector and can’t be called manual by user code or any service.
Finalize belongs to System.Object class.
Implement it when you have unmanaged resources in your code, and make sure that these resources are freed when the Garbage collection happens.

Dispose
Dispose is also used to free unmanaged resources that are not in use like files, database connections in the Application domain at any time.
Dispose is explicitly called by manual user code.
If we need to use the dispose method, we must implement that class via IDisposable interface.
It belongs to IDisposable interface.
Implement this when you are writing a custom class that will be used by other users.

19. What are delegates in C# and the uses of delegates?

A. A Delegate is an abstraction of one or more function pointers (as existed in C++; the explanation about this is out of the scope of this article). 
The .NET has implemented the concept of function pointers in the form of delegates. 
With delegates, you can treat a function as data. 
Delegates allow functions to be passed as parameters, returned from a function as a value and stored in an array. 

Delegates have the following characteristics:
-Delegates are derived from the System.MulticastDelegate class.
-They have a signature and a return type. A function that is added to delegates must be compatible with this signature.
-Delegates can point to either static or instance methods.
-Once a delegate object has been created, it may dynamically invoke the methods it points to at runtime.
-Delegates can call methods synchronously and asynchronously.

The delegate contains a couple of useful fields. The first one holds a reference to an object, and the second holds a method pointer.
When you invoke the delegate, the instance method is called on the contained reference. 
However, if the object reference is null then the runtime understands this to mean that the method is a static method. 
Moreover, invoking a delegate syntactically is the exact same as calling a regular function. 
Therefore, delegates are perfect for implementing callbacks.
 
Why Do We Need Delegates?
 
Historically, the Windows API made frequent use of C-style function pointers to create callback functions. 
Using a callback, programmers were able to configure one function to report back to another function in the application. 
So the objective of using a callback is to handle button-clicking, menu-selection, and mouse-moving activities. 
But the problem with this traditional approach is that the callback functions were not type-safe. 
In the .NET framework, callbacks are still possible using delegates with a more efficient approach.

Delegates maintain three important pieces of information:
-The parameters of the method.
-The address of the method it calls.
-The return type of the method.

A delegate is a solution for situations in which you want to pass methods around to other methods. 
You are so accustomed to passing data to methods as parameters that the idea of passing methods as an argument instead of data might sound a little strange. 
However, there are cases in which you have a method that does something, for instance, invoking some other method.
You do not know at compile time what this second method is.
That information is available only at runtime, hence Delegates are the device to overcome such complications.

Delegates Sample Program

The delegate implementation can cause a great deal of confusion when encountered the first time. 
Thus, it is a great idea to get an understanding by creating this sample program as: 
using System;
namespace Delegates  
{  
    // Delegate Definition  
    public delegate int operation(int x, int y);  
         
    class Program  
    {  
        // Method that is passes as an Argument  
        // It has same signature as Delegates   
        static int Addition(int a, int b)  
        {  
            return a + b;  
        }  
  
        static void Main(string[] args)  
        {  
            // Delegate instantiation  
            operation obj = new operation(Program.Addition);  
   
            // output  
            Console.WriteLine("Addition is={0}",obj(23,27));   
            Console.ReadLine();    
        }  
    }  
}  
Here, we are defining the delegate as a delegate type. 
The important point to remember is that the signature of the function reference by the delegate must match the delegate signature as:

// Delegate Definition  
public delegate int operation(int x, int y);  
Notice the format of the operation delegate type declaration; it specifies that the operation object can permit any method taking two integers and returning an integer.

When you want to insert the target methods to a given delegate object, simply pass in the name of the method to the delegate constructor as: 
// Delegate instantiation  
operation obj = new operation(Program.Addition);  

At this point, you are able to invoke the member pointed to using a direct function invocation as:
Console.WriteLine("Addition is={0}",obj(23,27));   
Finally, when the delegate is no longer required, set the delegate instance to null.

Recall that .NET delegates are type-safe. Therefore, if you attempt to pass a delegate a method that does not match the signature pattern,
the .NET will report a compile-time error.

20. What is IEnumerable<> in C#?

A. IEnumerable is the parent interface for all non-generic collections in System.Collections namespace 
like ArrayList, HastTable etc. that can be enumerated. 
For the generic version of this interface as 
IEnumerable<T> which a parent interface of all generic collections class in System.Collections.Generic namespace 
like List<> and more.

In System.Collections.Generic.IEnumerable<T> have only a single method which is GetEnumerator() that returns an IEnumerator. 
IEnumerator provides the power to iterate through the collection by exposing a Current property and Move Next and Reset methods
if we don’t have this interface as a parent so we can’t use iteration by foreach loop or can’t use that class object in our LINQ query.
 
21. What is the difference between late binding and early binding in C#?

A. Compile Time Polymorphism or Early Binding
 
In Compile time polymorphism or Early Binding, we will use multiple methods with the same name but different types of parameters, or maybe the number of parameters. 
Because of this, we can perform different-different tasks with the same method name in the same class which is also known as Method overloading.

Run Time Polymorphism or Late Binding
 
Run time polymorphism is also known as late binding. 
In Run Time Polymorphism or Late Binding, we can use the same method names with the same signatures, 
which means the same type or the same number of parameters, but not in the same class 
because the compiler doesn’t allow for that at compile time. 
Therefore, we can use that bind at run time in the derived class when a child class or derived class object will be instantiated. 
That’s why we call it Late Binding. 
We have to create my parent class functions as partial and in driver or child class as override functions with the override keyword.

class Class1{
public virtual string Testfunc()
{
  return "Hello";
}
}

class Class2 : Class1{
public override string Testfunc()
{
  return "Bye";
}
}

class Program{
static void Main(string [] args)
{
  Class2 obj = new Class2();
  obj.Testfunc();
  
}
}

22. What are the differences between IEnumerable and IQueryable?

A. IEnumerable
 
Is the parent interface for all non-generic collections in System.Collections namespace like ArrayList, HastTable, etc. that can be enumerated. 
The generic version of this interface is IEnumerable<T>, 
which a parent interface of all generic collections class in System.Collections.Generic namespace, like List<> and more. 

IQueryable
 
As per MSDN, the IQueryable interface is intended for implementation by query providers and belongs to System.Linq namespace. 
It is only supposed to be implemented by providers that also implement IQueryable<T>. 
If the provider does not also implement IQueryable<T>, the standard query operators cannot be used on the provider's data source.

-IEnumerable is great for working with in-memory collections, but 
IQueryable allows for a remote data source such as a database or web service.
-IEnumerable is the return type for LINQ to Object and LINQ to XML queries.
IQueryable is the return type of LINQ to SQL queries.
-IEnumerable doesn't support lazy loading, so it is not recommended for paging kind of scenarios.
IQueryable supports lazy loading and we can use paging kind of scenarios.

23. What happens if the inherited interfaces have conflicting method names?

A. We have to use the interface name before the method name to remove this method confiscation.

namespace ConsoleApplication1  
{  
    interface IShow  
    {  
        void Show();  
    }    
    interface IShow_Case  
    {  
        void Show();  
    }  
    class B : IShow, IShow_Case  
    {  
        public void IShow.Show()  
        {  
            Console.WriteLine("IShow Interface function");  
        }    
        public void IShow_Case.Show()  
        {  
            Console.WriteLine("IShow_Case Interface function");  
        }   
        static void Main(string[] args)  
  
        {  
            IShow I = new B();  
            I.Show();  // IShow Interface function
            IShow_Case I1 = new B();  
            I1.Show(); // IShow_Case Interface function
            Console.ReadKey(true);  
        }  
    }    
}  

Here you need to remove Public modifier from the methods, because it implement by using interface name to differentiate same method by their interface. 
We know interface by default Public so we need to remove Public modifier from the methods. 

24. What is the Constructor Chaining in C#?

A. Constructor chaining is a way to connect two or more classes in a relationship as Inheritance. 
In Constructor Chaining, every child class constructor is mapped to a parent class Constructor implicitly by base keyword, 
so when you create an instance of the child class, it will call the parent’s class Constructor. 
Without it, inheritance is not possible.

25. What’s the difference between the Array.CopyTo() and Array.Clone()?

A. The Array.Clone() method creates a shallow copy of an array. 
A shallow copy of an Array copies only the elements of the Array, whether they are reference types or value types, 
but it does not copy the objects that the references refer to.
The references in the new Array point to the same objects that the references in the original Array point to.

The CopyTo() static method of the Array class copies a section of an array to another array. 
The CopyTo method copies all the elements of an array to another one-dimension array.
The code listed in Listing 9 copies contents of an integer array to an array of object types.

26. What are Singleton Design Patterns and how to implement them in C#? 

A. What is a Singleton Design Pattern? 
1. Ensures a class has only one instance and provides a global point of access to it.
2. A Singleton is a class that only allows a single instance of itself to be created and usually gives simple access to that instance.
3. Most commonly, singletons don't allow any parameters to be specified when creating the instance 
since the second request of an instance with a different parameter could be problematic! 
(If the same instance should be accessed for all requests with the same parameter then the factory pattern is more appropriate.)
4. There are various ways to implement the Singleton Pattern in C#. The following are the common characteristics of a Singleton Pattern.
-A single constructor, that is private and parameterless.
-The class is sealed.
-A static variable that holds a reference to the single created instance, if any.
-A public static means of getting the reference to the single created instance, creating one if necessary.

Example of how to write code with Singleton:
namespace Singleton {  
    class Program {  
        static void Main(string[] args) {  
            Calculate.Instance.ValueOne = 10.5;  
            Calculate.Instance.ValueTwo = 5.5;  
            Console.WriteLine("Addition : " + Calculate.Instance.Addition());  
            Console.WriteLine("Subtraction : " + Calculate.Instance.Subtraction());  
            Console.WriteLine("Multiplication : " + Calculate.Instance.Multiplication());  
            Console.WriteLine("Division : " + Calculate.Instance.Division());  
            Console.WriteLine("\n----------------------\n");  
            Calculate.Instance.ValueTwo = 10.5;  
            Console.WriteLine("Addition : " + Calculate.Instance.Addition());  
            Console.WriteLine("Subtraction : " + Calculate.Instance.Subtraction());  
            Console.WriteLine("Multiplication : " + Calculate.Instance.Multiplication());  
            Console.WriteLine("Division : " + Calculate.Instance.Division());  
            Console.ReadLine();  
        }  
    }  
    public sealed class Calculate {  
        private Calculate() {}  
        private static Calculate instance = null;  
        public static Calculate Instance {  
            get {  
                if (instance == null) {  
                    instance = new Calculate();  
                }  
                return instance;  
            }  
        }  
        public double ValueOne {  
            get;  
            set;  
        }  
        public double ValueTwo {  
            get;  
            set;  
        }  
        public double Addition() {  
            return ValueOne + ValueTwo;  
        }  
        public double Subtraction() {  
            return ValueOne - ValueTwo;  
        }  
        public double Multiplication() {  
            return ValueOne * ValueTwo;  
        }  
        public double Division() {  
            return ValueOne / ValueTwo;  
        }  
    }  
}  

27. Difference between Throw Exception and Throw Clause.

A. The basic difference is that the Throw exception overwrites the stack trace. 
This makes it hard to find the original code line number that has thrown the exception.

Throw basically retains the stack information and adds to the stack information in the exception that it is thrown.

using System;  
using System.Collections.Generic;  
using System.Linq;  
using System.Text;  
namespace TestingThrowExceptions {  
    class Program {  
        public void ExceptionMethod() {  
            throw new Exception("Original Exception occurred in ExceptionMethod");  
        }  
        static void Main(string[] args) {  
            Program p = new Program();  
            try {  
                p.ExceptionMethod();  
            } catch (Exception ex) {  
                throw ex;  
            }  
        }  
    }  
}  
It returns an exception and look at the stack trace.

28. What are Indexers in C#?

A. C# introduces a new concept known as Indexers which are used for treating an object as an array. 
The indexers are usually known as smart arrays in C#. They are not an essential part of object-oriented programming.
 
Defining an indexer allows you to create classes that act as virtual arrays. 
Instances of that class can be accessed using the [] array access operator.

Creating an Indexer 
< modifier > < return type > this[argument list] {    
    get {    
        // your get block code    
    }    
    set {    
        // your set block code    
    }    
}    
In the above code,
 
<modifier>
 
can be private, public, protected or internal.
 
<return type>
 
can be any valid C# types.

29. SOLID principles

A. SOLID principles are the design principles that enable us to manage most of the software design problems.
S: Single Responsibility Principle (SRP)
O: Open closed Principle (OCP)
L: Liskov substitution Principle (LSP)
I: Interface Segregation Principle (ISP)
D: Dependency Inversion Principle (DIP)

S: Single Responsibility Principle (SRP)
This means that every class, or similar structure, in your code should have only one job to do.
Everything in that class should be related to a single purpose. 
Our class should not be like a Swiss knife wherein if one of them needs to be changed then the entire tool needs to be altered. 
It does not mean that your classes should only contain one method or property. 
There may be many members as long as they relate to single responsibility.

The Single Responsibility Principle gives us a good way of identifying classes at the design phase of an application and it makes you think of all the ways a class can change. 
A good separation of responsibilities is done only when we have the full picture of how the application should work.

public class UserService  
{  
   public void Register(string email, string password)  
   {  
      if (!ValidateEmail(email))  
         throw new ValidationException("Email is not an email");  
         var user = new User(email, password);  
  
         SendEmail(new MailMessage("mysite@nowhere.com", email) { Subject="HEllo foo" });  
   }
   public virtual bool ValidateEmail(string email)  
   {  
     return email.Contains("@");  
   }  
   public bool SendEmail(MailMessage message)  
   {  
     _smtpClient.Send(message);  
   }  
}   

It looks fine, but it is not following SRP.
The SendEmail and ValidateEmail methods have nothing to do within the UserService class. Let's refract it.

public class UserService  
{  
   EmailService _emailService;  
   DbContext _dbContext;  
   public UserService(EmailService aEmailService, DbContext aDbContext)  
   {  
      _emailService = aEmailService;  
      _dbContext = aDbContext;  
   }  
   public void Register(string email, string password)  
   {  
      if (!_emailService.ValidateEmail(email))  
         throw new ValidationException("Email is not an email");  
         var user = new User(email, password);  
         _dbContext.Save(user);  
         emailService.SendEmail(new MailMessage("myname@mydomain.com", email) {Subject="Hi. How are you!"});  
  
      }  
   }  
   public class EmailService  
   {  
      SmtpClient _smtpClient;  
   public EmailService(SmtpClient aSmtpClient)  
   {  
      _smtpClient = aSmtpClient;  
   }  
   public bool virtual ValidateEmail(string email)  
   {  
      return email.Contains("@");  
   }  
   public bool SendEmail(MailMessage message)  
   {  
      _smtpClient.Send(message);  
   }  
}   

O: Open/Closed Principle
The Open/closed Principle says "A software module/class is open for extension and closed for modification".
Here "Open for extension" means, we need to design our module/class in such a way that the new functionality can be added only when new requirements are generated.
"Closed for modification" means we have already developed a class and it has gone through unit testing. We should then not alter it until we find bugs. 
As it says, a class should be open for extensions, we can use inheritance to do this. Okay, let's dive into an example.

Suppose we have a Rectangle class with the properties Height and Width.
public class Rectangle{  
   public double Height {get;set;}  
   public double Wight {get;set; }  
}  

Our app needs the ability to calculate the total area of a collection of Rectangles. 
Since we already learned the Single Responsibility Principle (SRP), we don't need to put the total area calculation code inside the rectangle. 
So here I created another class for area calculation.
public class AreaCalculator {  
   public double TotalArea(Rectangle[] arrRectangles)  
   {  
      double area;  
      foreach(var objRectangle in arrRectangles)  
      {  
         area += objRectangle.Height * objRectangle.Width;  
      }  
      return area;  
   }  
}  
 
can we extend our app so that it could calculate the area of not only Rectangles but also the area of Circles as well? 
Now we have an issue with the area calculation issue because the way to do circle area calculation is different.
We can change the TotalArea method a bit so that it can accept an array of objects as an argument. 
We check the object type in the loop and do area calculation based on the object type.
public class Rectangle{  
   public double Height {get;set;}  
   public double Wight {get;set; }  
}  
public class Circle{  
   public double Radius {get;set;}  
}  
public class AreaCalculator  
{  
   public double TotalArea(object[] arrObjects)  
   {  
      double area = 0;  
      Rectangle objRectangle;  
      Circle objCircle;  
      foreach(var obj in arrObjects)  
      {  
         if(obj is Rectangle)  
         {    
            area += obj.Height * obj.Width;  
         }  
         else  
         {  
            objCircle = (Circle)obj;  
            area += objCircle.Radius * objCircle.Radius * Math.PI;  
         }  
      }  
      return area;  
   }  
}  

L: Liskov Substitution Principle
The Liskov Substitution Principle (LSP) states that 
"you should be able to use any derived class instead of a parent class and have it behave in the same manner without modification".
It ensures that a derived class does not affect the behavior of the parent class, in other words,, that a derived class must be substitutable for its base class.

This principle is just an extension of the Open Closed Principle and 
it means that we must ensure that new derived classes extend the base classes without changing their behavior.

Now jump into an example to learn how a design can violate LSP.
Suppose we need to build an app to manage data using a group of SQL files text.
Here we need to write functionality to load and save the text of a group of SQL files in the application directory.
So we need a class that manages the load and saves the text of group of SQL files along with the SqlFile Class. 

public class SqlFile  
{  
   public string FilePath {get;set;}  
   public string FileText {get;set;}  
   public string LoadText()  
   {  
      /* Code to read text from sql file */  
   }  
   public string SaveText()  
   {  
      /* Code to save text into sql file */  
   }  
}  
public class SqlFileManager  
{  
   public List<SqlFile> lstSqlFiles {get;set}  
  
   public string GetTextFromFiles()  
   {  
      StringBuilder objStrBuilder = new StringBuilder();  
      foreach(var objFile in lstSqlFiles)  
      {  
         objStrBuilder.Append(objFile.LoadText());  
      }  
      return objStrBuilder.ToString();  
   }  
   public void SaveTextIntoFiles()  
   {  
      foreach(var objFile in lstSqlFiles)  
      {  
         objFile.SaveText();  
      }  
   }  
}  

OK. We are done with our part. The functionality looks good for now.
After some time our leaders might tell us that we may have a few read-only files in the application folder, 
so we need to restrict the flow whenever it tries to do a save on them.
 
OK. We can do that by creating a "ReadOnlySqlFile" class that inherits the "SqlFile" class and 
we need to alter the SaveTextIntoFiles() method by introducing a condition to prevent calling the SaveText() method on ReadOnlySqlFile instances.

public class SqlFile  
{  
   public string LoadText()  
   {  
   /* Code to read text from sql file */  
   }  
   public void SaveText()  
   {  
      /* Code to save text into sql file */  
   }  
}  
public class ReadOnlySqlFile: SqlFile  
{  
   public string FilePath {get;set;}  
   public string FileText {get;set;}  
   public string LoadText()  
   {  
      /* Code to read text from sql file */  
   }  
   public void SaveText()  
   {  
      /* Throw an exception when app flow tries to do save. */  
      throw new IOException("Can't Save");  
   }  
}  

To avoid an exception we need to modify "SqlFileManager" by adding one condition to the loop.
public class SqlFileManager  
{  
   public List<SqlFile? lstSqlFiles {get;set}  
   public string GetTextFromFiles()  
   {  
      StringBuilder objStrBuilder = new StringBuilder();  
      foreach(var objFile in lstSqlFiles)  
      {  
         objStrBuilder.Append(objFile.LoadText());  
      }  
      return objStrBuilder.ToString();  
   }  
   public void SaveTextIntoFiles()  
   {  
      foreach(var objFile in lstSqlFiles)  
      {  
         //Check whether the current file object is read-only or not.If yes, skip calling it's  
         // SaveText() method to skip the exception.  
  
         if(! objFile is ReadOnlySqlFile)  
         objFile.SaveText();  
      }  
   }  
}  

Here we altered the SaveTextIntoFiles() method in the SqlFileManager class to determine whether or not the instance is of ReadOnlySqlFile to avoid the exception.
We can't use this ReadOnlySqlFile class as a substitute for its parent without altering SqlFileManager code. 
So we can say that this design is not following LSP. 
Let's make this design follow the LSP. Here we will introduce interfaces to make the SqlFileManager class independent from the rest of the blocks.
public interface IReadableSqlFile  
{  
   string LoadText();  
}  
public interface IWritableSqlFile  
{  
   void SaveText();  
}  
Now we implement IReadableSqlFile through the ReadOnlySqlFile class that reads only the text from read-only files.
public class ReadOnlySqlFile: IReadableSqlFile  
{  
   public string FilePath {get;set;}  
   public string FileText {get;set;}  
   public string LoadText()  
   {  
      /* Code to read text from sql file */  
   }  
}  
Here we implement both IWritableSqlFile and IReadableSqlFile in a SqlFile class by which we can read and write files.
public class SqlFile: IWritableSqlFile,IReadableSqlFile  
{  
   public string FilePath {get;set;}  
   public string FileText {get;set;}  
   public string LoadText()  
   {  
      /* Code to read text from sql file */  
   }  
   public void SaveText()  
   {  
      /* Code to save text into sql file */  
   }  
}  
Now the design of the SqlFileManager class becomes like this:
public class SqlFileManager  
{  
   public string GetTextFromFiles(List<IReadableSqlFile> aLstReadableFiles)  
   {  
      StringBuilder objStrBuilder = new StringBuilder();  
      foreach(var objFile in aLstReadableFiles)  
      {  
         objStrBuilder.Append(objFile.LoadText());  
      }  
      return objStrBuilder.ToString();  
   }  
   public void SaveTextIntoFiles(List<IWritableSqlFile> aLstWritableFiles)  
   {  
   foreach(var objFile in aLstWritableFiles)  
   {  
      objFile.SaveText();  
   }  
   }  
}  
Here the GetTextFromFiles() method gets only the list of instances of classes that implement the IReadOnlySqlFile interface. 
That means the SqlFile and ReadOnlySqlFile class instances. 
And the SaveTextIntoFiles() method gets only the list instances of the class that implements the IWritableSqlFiles interface,
in other words, SqlFile instances in this case. Now we can say our design is following the LSP. 
And we fixed the problem using the Interface segregation principle by (ISP) identifying the abstraction and the responsibility separation method.

I: Interface Segregation Principle (ISP)
The Interface Segregation Principle states "that clients should not be forced to implement interfaces they don't use. 
Instead of one fat interface, many small interfaces are preferred based on groups of methods, each one serving one submodule."

Like classes, each interface should have a specific purpose/responsibility (refer to SRP).
You shouldn't be forced to implement an interface when your object doesn't share that purpose. 
The larger the interface, the more likely it includes methods that not all implementers can do. 
That's the essence of the Interface Segregation Principle.

Let's start with an example that breaks the ISP. 
Suppose we need to build a system for an IT firm that contains roles like TeamLead and Programmer where 
TeamLead divides a huge task into smaller tasks and assigns them to his/her programmers or can directly work on them.

Based on specifications, we need to create an interface and a TeamLead class to implement it. 
public Interface ILead  
{  
   void CreateSubTask();  
   void AssginTask();  
   void WorkOnTask();  
}  
public class TeamLead : ILead  
{  
   public void AssignTask()  
   {  
      //Code to assign a task.  
   }  
   public void CreateSubTask()  
   {  
      //Code to create a sub task  
   }  
   public void WorkOnTask()  
   {  
      //Code to implement perform assigned task.  
   }  
}  

Later another role like Manager, who assigns tasks to TeamLead and will not work on the tasks, is introduced into the system.
Can we directly implement an ILead interface in the Manager class, like the following?
public class Manager: ILead  
{  
   public void AssignTask()  
   {  
      //Code to assign a task.  
   }  
   public void CreateSubTask()  
   {  
      //Code to create a sub task.  
   }  
   public void WorkOnTask()  
   {  
      throw new Exception("Manager can't work on Task");  
   }  
}  

Since the Manager can't work on a task and at the same time no one can assign tasks to the Manager, this WorkOnTask() should not be in the Manager class. 
But we are implementing this class from the ILead interface, we need to provide a concrete Method. 
Here we are forcing the Manager class to implement a WorkOnTask() method without a purpose. This is wrong. 
The design violates ISP. Let's correct the design.
Since we have three roles, 
1. Manager, that can only divide and assign the tasks, 
2. TeamLead that can divide and assign the tasks and can work on them as well, 
3. The programmer that can only work on tasks, we need to divide the responsibilities by segregating the ILead interface.
An interface that provides a contract for WorkOnTask().
public interface IProgrammer  
{  
   void WorkOnTask();  
}  
An interface that provides contracts to manage the tasks:
public interface ILead  
{  
   void AssignTask();  
   void CreateSubTask();  
}  
Then the implementation becomes:
public class Programmer: IProgrammer  
{  
   public void WorkOnTask()  
   {  
      //code to implement to work on the Task.  
   }  
}  
public class Manager: ILead  
{  
   public void AssignTask()  
   {  
      //Code to assign a Task  
   }  
   public void CreateSubTask()  
   {  
   //Code to create a sub taks from a task.  
   }  
}  
TeamLead can manage tasks and can work on them if needed. Then the TeamLead class should implement both of the IProgrammer and ILead interfaces.
public class TeamLead: IProgrammer, ILead  
{  
   public void AssignTask()  
   {  
      //Code to assign a Task  
   }  
   public void CreateSubTask()  
   {  
      //Code to create a sub task from a task.  
   }  
   public void WorkOnTask()  
   {  
      //code to implement to work on the Task.  
   }  
}  
Wow. Here we separated responsibilities/purposes and distributed them on multiple interfaces and provided a good level of abstraction too.

D: Dependency Inversion Principle
The Dependency Inversion Principle (DIP) states that high-level modules/classes should not depend on low-level modules/classes.
Both should depend upon abstractions. 
Secondly, abstractions should not depend upon details.
Details should depend upon abstractions.

High-level modules/classes implement business rules or logic in a system (application). 
Low-level modules/classes deal with more detailed operations; 
in other words they may deal with writing information to databases or passing messages to the operating system or services.

A high-level module/class that has a dependency on low-level modules/classes or 
some other class and knows a lot about the other classes it interacts with is said to be tightly coupled. 
When a class knows explicitly about the design and implementation of another class, it raises the risk that changes to one class will break the other class. 
So we must keep these high-level and low-level modules/classes loosely coupled as much as we can. 
To do that, we need to make both of them dependent on abstractions instead of knowing each other.
Let's start with an example.

Suppose we need to work on an error logging module that logs exception stack traces into a file. Simple, isn't it?
The following are the classes that provide the functionality to log a stack trace into a file. 
public class FileLogger  
{  
   public void LogMessage(string aStackTrace)  
   {  
      //code to log stack trace into a file.  
   }  
}  
public class ExceptionLogger  
{  
   public void LogIntoFile(Exception aException)  
   {  
      FileLogger objFileLogger = new FileLogger();  
      objFileLogger.LogMessage(GetUserReadableMessage(aException));  
   }  
   private GetUserReadableMessage(Exception ex)  
   {  
      string strMessage = string. Empty;  
      //code to convert Exception's stack trace and message to user readable format.  
      ....  
      ....  
      return strMessage;  
   }  
}  
A client class exports data from many files to a database.
public class DataExporter  
{  
   public void ExportDataFromFile()  
   {  
   try {  
      //code to export data from files to database.  
   }  
   catch(Exception ex)  
   {  
      new ExceptionLogger().LogIntoFile(ex);  
   }  
}  
}  
Looks good. We sent our application to the client. 
But our client wants to store this stack trace in a database if an IO exception occurs. 
Hmm... okay, no problem. We can implement that too. 
Here we need to add one more class that provides the functionality to log the stack trace into the database and
an extra method in ExceptionLogger to interact with our new class to log the stack trace.
public class DbLogger  
{  
   public void LogMessage(string aMessage)  
   {  
      //Code to write message in database.  
   }  
}  
public class FileLogger  
{  
   public void LogMessage(string aStackTrace)  
   {  
      //code to log stack trace into a file.  
   }  
}  
public class ExceptionLogger  
{  
   public void LogIntoFile(Exception aException)  
   {  
      FileLogger objFileLogger = new FileLogger();  
      objFileLogger.LogMessage(GetUserReadableMessage(aException));  
   }  
   public void LogIntoDataBase(Exception aException)  
   {  
      DbLogger objDbLogger = new DbLogger();  
      objDbLogger.LogMessage(GetUserReadableMessage(aException));  
   }  
   private string GetUserReadableMessage(Exception ex)  
   {  
      string strMessage = string.Empty;  
      //code to convert Exception's stack trace and message to user readable format.  
      ....  
      ....  
      return strMessage;  
   }  
}  
public class DataExporter  
{  
   public void ExportDataFromFile()  
   {  
      try {  
         //code to export data from files to database.  
      }  
      catch(IOException ex)  
      {  
         new ExceptionLogger().LogIntoDataBase(ex);  
      }  
      catch(Exception ex)  
      {  
         new ExceptionLogger().LogIntoFile(ex);  
      }  
   }  
}  
Looks fine for now. But whenever the client wants to introduce a new logger, we need to alter ExceptionLogger by adding a new method. 
If we continue doing this after some time then we will see a fat ExceptionLogger class with a large set of methods 
that provide the functionality to log a message into various targets. 
Why does this issue occur? Because ExceptionLogger directly contacts the low-level classes FileLogger and DbLogger to log the exception.
We need to alter the design so that this ExceptionLogger class can be loosely coupled with those classes. 
To do that we need to introduce an abstraction between them so that ExcetpionLogger can contact the abstraction to log the exception 
instead of depending on the low-level classes directly.
public interface ILogger  
{  
   void LogMessage(string aString);  
} 
Now our low-level classes need to implement this interface.
public class DbLogger: ILogger  
{  
   public void LogMessage(string aMessage)  
   {  
      //Code to write message in database.  
   }  
}  
public class FileLogger: ILogger  
{  
   public void LogMessage(string aStackTrace)  
   {  
      //code to log stack trace into a file.  
   }  
}  
Now, we move to the low-level class's initiation from the ExcetpionLogger class to the DataExporter class to make
ExceptionLogger loosely coupled with the low-level classes FileLogger and EventLogger.
And by doing that we are giving provision to DataExporter class to decide what kind of Logger should be called based on the exception that occurs.
public class ExceptionLogger  
{  
   private ILogger _logger;  
   public ExceptionLogger(ILogger aLogger)  
   {  
      this._logger = aLogger;  
   }  
   public void LogException(Exception aException)  
   {  
      string strMessage = GetUserReadableMessage(aException);  
      this._logger.LogMessage(strMessage);  
   }  
   private string GetUserReadableMessage(Exception aException)  
   {  
      string strMessage = string.Empty;  
      //code to convert Exception's stack trace and message to user readable format.  
      ....  
      ....  
      return strMessage;  
   }  
}  
public class DataExporter  
{  
   public void ExportDataFromFile()  
   {  
      ExceptionLogger _exceptionLogger;  
      try {  
         //code to export data from files to database.  
      }  
      catch(IOException ex)  
      {  
         _exceptionLogger = new ExceptionLogger(new DbLogger());  
         _exceptionLogger.LogException(ex);  
      }  
      catch(Exception ex)  
      {  
         _exceptionLogger = new ExceptionLogger(new FileLogger());  
         _exceptionLogger.LogException(ex);  
      }  
   }  
}  
We successfully removed the dependency on low-level classes. 
This ExceptionLogger doesn't depend on the FileLogger and EventLogger classes to log the stack trace. 
We don't need to change the ExceptionLogger's code anymore for any new logging functionality. 
We need to create a new logging class that implements the ILogger interface and must add another catch block to the DataExporter class's ExportDataFromFile method.
public class EventLogger: ILogger  
{  
   public void LogMessage(string aMessage)  
   {  
      //Code to write message in system's event viewer.  
   }  
}  
And we need to add a condition in the DataExporter class as in the following:
public class DataExporter  
{  
   public void ExportDataFromFile()  
   {  
      ExceptionLogger _exceptionLogger;  
      try {  
         //code to export data from files to database.  
      }  
      catch(IOException ex)  
      {  
         _exceptionLogger = new ExceptionLogger(new DbLogger());  
         _exceptionLogger.LogException(ex);  
      }  
      catch(SqlException ex)  
      {  
         _exceptionLogger = new ExceptionLogger(new EventLogger());  
         _exceptionLogger.LogException(ex);  
      }  
      catch(Exception ex)  
      {  
         _exceptionLogger = new ExceptionLogger(new FileLogger());  
         _exceptionLogger.LogException(ex);  
      }  
   }  
}  
Looks good. But we introduced the dependency here in the DataExporter class's catch blocks.
Yeah, someone must take the responsibility to provide the necessary objects to the ExceptionLogger to get the work done.
 
Let me explain it with a real-world example. 
Suppose we want to have a wooden chair with specific measurements and the kind of wood to be used to make that chair. 
Then we can't leave the decision making on measurements and the wood to the carpenter. 
Here his job is to make a chair based on our requirements with his tools and we provide the specifications to him to make a good chair.
 
So what is the benefit we get by the design?
Yes, we definitely have a benefit with it.
We need to modify both the DataExporter class and ExceptionLogger class whenever we need to introduce a new logging functionality. 
But in the updated design we need to add only another catch block for the new exception logging feature. Coupling is not inherently evil.
If you don't have some amount of coupling, your software will not do anything for you. 
The only thing we need to do is understand the system, requirements, and environment properly and find areas where DIP should be followed.

30. What is Multicast Delegate in C#?

A. A Multicast Delegate is a delegate that holds the references of more than one function. 
When we invoke the multicast delegate, then all the functions which are referenced by the delegate are going to be invoked. 
If you want to call multiple methods using a delegate then all the method signature should be the same.

namespace MulticastDelegateDemo
{
    public delegate void RectangleDelete(double Width, double Height);
    public class Rectangle
    {
        public void GetArea(double Width, double Height)
        {
            Console.WriteLine(@"Area is {0}", (Width * Height));
        }
        public void GetPerimeter(double Width, double Height)
        {
            Console.WriteLine(@"Perimeter is {0}", (2 * (Width + Height)));
        }
        static void Main(string[] args)
        {
            Rectangle rect = new Rectangle();
            RectangleDelete rectDelegate = new RectangleDelete(rect.GetArea);
            //RectangleDelete rectDelegate = rect.GetArea;

            //binding a method with delegate object
            // In this example rectDelegate is a multicast delegate. You use += operator 
            // to chain delegates together and -= operator to remove.

            rectDelegate += rect.GetPerimeter;
            rectDelegate(23.45, 67.89);

            Console.WriteLine();
            rectDelegate.Invoke(13.45, 76.89);

            Console.WriteLine();
            //Removing a method from delegate object
            rectDelegate -= rect.GetPerimeter;
            rectDelegate.Invoke(13.45, 76.89);

            Console.ReadKey();
        }
    }
}
OUTPUT:
Area is 1592.0205
Perimeter is 182.68

Area is 1034.1705
Perimeter is 180.68

Area is 1034.1705

31. Checked and unchecked keyword in C#

A. The C# provides checked and unchecked keyword which are used to handle integral type exceptions.
The checked keyword in C# is used to explicitly enable overflow checking for integral-type arithmetic operations and conversions.

The unchecked keyword in C# is used to suppress overflow-checking for integral-type arithmetic operations and conversions.

Here, overflow checking means when the value of any integral-type exceeds its range, it does not raises any exception,
instead it will give us unexpected or garbage results.

Example without Checked Keyword:
Now, let’s see where the checked keyword can help us in making your code more useful.
In the following example, you can see that we have three integer variables. 
The integer variables a and b holds the maximum value that an integer can hold. 
Then we just simply add the integer a and b and stored it in the third integer variable i.e. c.

using System;
namespace CheckedUncheckedDemo
{
    class Program
    {
        static void Main(string[] args)
        {
            int a = 2147483647;
            int b= 2147483647;

            int c = a + b;

            Console.WriteLine(c); //-2
            Console.ReadLine();
        }
    }
}

Example: Using Checked Keyword
As we use the checked keyword, it should throws runtime exception rather than displaying -2.

using System;
namespace CheckedUncheckedDemo
{
    class Program
    {
        static void Main(string[] args)
        {
            int a = 2147483647;
            int b= 2147483647;
            int c = checked(a + b);
            Console.WriteLine(c);
            Console.ReadLine();
        }
    }
}

Unchecked keyword in C#:
int c = unchecked(a + b); // Output: -2
So this proves that the unchecked keyword works almost the same way as the default compiler works.

