Char.IsNumber(Char)  //method to check whether the specified Unicode character matches number or not

using System;
class GFG {
 
    // Main Method
    static public void Main()
    {
 
        // Declaration of data type
        bool result;
 
        // checking if 5 is a
        // number or not
        char ch1 = '5';
        result = Char.IsNumber(ch1);
        Console.WriteLine(result);    //True
 
        // checking if 'c' is a
        // number or not
        char ch2 = 'c';
        result = Char.IsNumber(ch2);
        Console.WriteLine(result);    //False
    }
}

Char.IsNumber(String, Int32) //method is used to check whether the specified string at specified position matches with any number or not.
 
using System;
class GFG {
 
    // Main Method
    static public void Main()
    {
 
        // Declaration of data type
        bool result;
 
        // checking for number in a
        // string at a desired position
        string str1 = "GeeksforGeeks";
        result = Char.IsNumber(str1, 2);
        Console.WriteLine(result);        //False
 
        // checking for number in a
        // string at a desired position
        string str2 = "geeks5forgeeks";
        result = Char.IsNumber(str2, 5);  //True
        Console.WriteLine(result);
    }
}

C# Serialization & Deserialization
//Serialization is a concept in which C# class objects are written or serialized to files.
//example C# class Tutorial having 2 properties ID and Tutorial name
//Serializing can be used to directly write the data properties of the Tutorial class to a file.
//Deserialization is used to read the data from the file and construct the Tutorial object again.
using System;
using System.IO;
using System.Linq;
using System.Runtime.Serialization;
using System.Runtime.Serialization.Formatters.Binary;
using System.Text;
using System.Threading.Tasks;
namespace DemoApplication
{
  [Serializable]
  class Tutorial
  {
  public int ID;
  public String Name;
   static void Main(string[] args)
   {
    Tutorial obj = new Tutorial();
    obj.ID = 1;
    obj.Name = ".Net";
 
    //create the file stream
    IFormatter formatter = new BinaryFormatter();
    Stream stream = new FileStream(@"E:\ExampleNew.txt",FileMode.Create,FileAccess.Write);

    //serialize the object
    formatter.Serialize(stream, obj);
    stream.Close();

    //create the file stream
    stream = new FileStream(@"E:\ExampleNew.txt",FileMode.Open,FileAccess.Read);
    
    //deserialize the object
    Tutorial objnew = (Tutorial)formatter.Deserialize(stream);

    //write data to the console
    Console.WriteLine(objnew.ID);
    Console.WriteLine(objnew.Name);

    Console.ReadKey();
  }
 }
}

# Questions
==================
1. What are the differences between ref and out keywords?

A. C# ref keywords pass arguments by reference and not value. To use the ‘ref’ keyword, you need to explicitly mention ‘ref’. 

void Method(ref int refArgument)
{
   refArgument = refArgument + 10;
}
int number = 1;
Method(ref number);
Console.WriteLine(number);
// Output: 11

C# out keywords pass arguments within methods and functions. 
‘out’ keyword is used to pass arguments in a method as a reference to return multiple values. 
Although it is the same as the ref keyword, the ref keyword needs to be initialised before it is passed. 
Here, The out and ref keywords are useful when we want to return a value in the same variables that are passed as an argument. 

public static string GetNextFeature(ref int id)  
{  
   string returnText = "Next-" + id.ToString();  
   id += 1;  
   return returnText;  
}  
public static string GetNextFeature(out int id)  
{  
   id = 1;  
   string returnText = "Next-" + id.ToString();  
   return returnText;  
}   

2. What are extension methods in C#?

A. Extension methods help to add new methods to the existing ones. 
The methods that are added are static. 
At times, when you want to add methods to an existing class but don’t perceive the right to modify that class or don’t hold the rights, 
you can create a new static class containing the new methods.
Once the extended methods are declared, bind this class with the existing one and see the methods will be added to the existing one.

// C# program to illustrate the concept
// of the extension methods
using System;
 
namespace ExtensionMethod {
static class NewMethodClass {
 
   // Method 4
   public static void M4(this Scaler s)
   {
       Console.WriteLine("Method Name: M4");
   }
 
   // Method 5
   public static void M5(this Scaler s, string str)
   {
       Console.WriteLine(str);
   }
}
 
// Now we create a new class in which
// Scaler class access all the five methods
public class IB {
 
   // Main Method
   public static void Main(string[] args)
   {
       Scaler s = new Scaler();
       s.M1();
       s.M2();
       s.M3();
       s.M4();
       s.M5("Method Name: M5");
   }
}
}
Output:

Method Name: M1

Method Name: M2

Method Name: M3

Method Name: M4

Method Name: M5

3. What are Generics in C#?

A. In C# collections, defining any kind of object is termed okay which compromises C#’s basic rule of type-safety. 
Therefore, generics were included to type-safe the code by allowing re-use of the data processing algorithms. 
Generics in C# mean not linked to any specific data type. Generics reduce the load of using boxing, unboxing, and typecasting objects.
Generics are always defined inside angular brackets <>. To create a generic class, this syntax is used:

GenericList<float> list1 = new GenericList<float>();
GenericList<Features> list2 = new GenericList<Features>();
GenericList<Struct> list3 = new GenericList<Struct>();

Here, GenericList<float> is a generic class. 
In each of these instances of GenericList<T>, every occurrence of T in the class is substituted at run time with the type argument. 
By substituting the T, we have created three different type-safe using the same class. 

4. What is the difference between an Array and ArrayList in C#?

A. An array is a collection of similar variables clubbed together under one common name. 
While ArrayList is a collection of objects that can be indexed individually.
With ArrayList you can access a number of features like dynamic memory allocation, adding, searching, and sorting items in the ArrayList. 

=>When declaring an array the size of the items is fixed therefore, the memory allocation is fixed. But with ArrayList, it can be increased or decreased dynamically.
=>Array belongs to system.array namespace while ArrayList belongs to the system.collection namespace.
=>All items in an array are of the same datatype while all the items in an ArrayList can be of the same or different data types.
=>While arrays cannot accept null, ArrayList can accept null values.

For ex.:

// C# program to illustrate the ArrayList
using System;
using System.Collections;
 
class IB {
 
   // Main Method
   public static void Main(string[] args)
   {
 
       // Create a list of strings
       ArrayList al = new ArrayList();
       al.Add("Bruno");
       al.Add("Husky");
       al.Add(10);
       al.Add(10.10);
 
       // Iterate list element using foreach loop
       foreach(var names in al)
       {
           Console.WriteLine(names);
       }
   }
}

5. What is inheritance? Does C# support multiple inheritance?

A. Inheritance means acquiring some of the properties from a master class.     A     B
                                                                                \   /
                                                                                  C
Here, class C can inherit properties from Class A and Class B. But, C# doesn’t support multiple inheritances. 
Instead, you can use interfaces to inherit the properties using the class name in the signature.

// C# program to illustrate
// multiple class inheritance
using System;
using System.Collections;

// Parent class 1
class Scaler {

  // Providing the implementation
  // of features() method
  public void features()
  {

      // Creating ArrayList
      ArrayList My_features= new ArrayList();

      // Adding elements in the
      // My_features ArrayList
      My_features.Add("Abstraction");
      My_features.Add("Encapsulation");
      My_features.Add("Inheritance");

      Console.WriteLine("Features provided by OOPS:");
      foreach(var elements in My_features)
      {
          Console.WriteLine(elements);
      }
  }
}

// Parent class 2
class Scaler2 :Scaler{

  // Providing the implementation
  // of courses() method
  public void languages()
  {

      // Creating ArrayList
      ArrayList My_features = new ArrayList();

      // Adding elements in the
      // My_features ArrayList
      My_features.Add("C++");
      My_features.Add("C#");
      My_features.Add("JScript");
     

      Console.WriteLine("\nLanguages that use OOPS concepts:");
      foreach(var elements in My_features)
      {
          Console.WriteLine(elements);
      }
  }
}

// Child class
class ScalertoScaler : Scaler2 {
}

public class Scaler1 {

  // Main method
  static public void Main()
  {

      // Creating object of ScalertoScaler class
      ScalertoScaler obj = new ScalertoScaler();
      obj.features();
      obj.languages();
  }
}

6. What is Boxing and Unboxing in C#?

A. Boxing: Boxing converts value type (int, char, etc.) to reference type (object) which is an implicit conversion process using object value. 
int num = 23; // 23 will assigned to num
Object Obj = num; // Boxing

Unboxing: Unboxing converts reference type (object) to value type (int, char, etc.) using an explicit conversion process. 
int num = 23;         // value type is int and assigned value 23
Object Obj = num;    // Boxing
int i = (int)Obj;    // Unboxing

7. What are Properties in C#?

A. Properties in C# are public members of a class where they provide the ability to access private members of a class. 
The basic principle of encapsulation lets you hide some sensitive properties from the users by making the variables private. 
The private members are not accessible otherwise in a class. 
Therefore, by using properties in C# you can easily access the private members and set their values. 

The values can be easily assigned using get and set methods, also known as accessors.
While the get method extracts the value, the set method assigns the value to the variables.

8. What are partial classes in C#?

A. Partial classes implement the functionality of a single class into multiple files. 
These multiple files are combined into one during compile time. The partial class can be created using the partial keyword. 

public partial Clas_name  
{
       // code
}

Partial Classes can be created in the same namespace. It isn't possible to create a partial class in a different namespace. 
So use the “partial” keyword with all the class names that you want to bind together with the same name of a class in the same namespace.

partial class Class1{
      public void function1()
      {
        Console.WriteLine("function 1");
      }
}
partial class Class1{
      public void function2()
      {
        Console.WriteLine("function 2");
      }
}

class Program{
      static void Main(string [] args)
      {
        Class1 obj = new Class1();
        obj.function1();
        obj.function2();
      }
}

You can easily split the functionalities of methods, interfaces, or structures into multiple files. 
You can even add nested partial classes. 

9.  What is the difference between late binding and early binding in C#?

A. Late binding and early binding are examples of one of the primary concepts of OOPS: Polymorphism. 

For ex: one function calculateBill() will calculate bills of premium customers, basic customers, and semi-premium customers based on their policies differently.
The calculation for all the customer objects is done differently using the same function which is called polymorphism. 

When an object is assigned to an object variable in C#, the .NET framework performs the binding. 

When the binding function happens at compile-time, it is called early binding. 
It investigates and checks the methods and properties of the static objects. 
With early binding, the number of run-time errors decreases substantially and it executes pretty quickly. 

But when the binding happens at runtime, it is called late binding. 
Late binding happens when the objects are dynamic (decided based on the data they hold) at run-time. 
It is slower as it looks through during run-time.

10. Arrays in C#

A. A few pointers for arrays in C#:

-The memory allocation is DYNAMIC.
-Arrays in C# are treated as objects.
-The length of the array is easy to find by detecting the number of members in the array.
-The members in the array are ordered and begin with the index value=0.
-The array types are reference types derived from the base array type.
-Syntax: < Data Type > [ ] < Name_Array >

11. What are Indexers in C#?

A. Indexers are called smart arrays that allow access to a member variable. 
Indexers allow member variables using the features of an array. They are created using the Indexer keyword. 
Indexers are not static members. 

For ex. Here the indexer is defined the same way.

<return type> this[<parameter type> index]
{
   get{
       // return the value from the specified index of an internal collection
   }
   set{
       // set values at the specified index in an internal collection
   }
}

12. Difference between the Equality Operator (==) and Equals() Method in C#?

A. Although both are used to compare two objects by value, still they both are used differently. 

For ex.:

int x = 10;
int y = 10;
Console.WriteLine( x == y);
Console.WriteLine(x.Equals(y));
Output:
True
True

Equality operator (==) is a reference type which means that if equality operator is used, it will return true only if both the references point to the same object.  

Equals() method: Equals method is used to compare the values carried by the objects. 
int x=10, int y=10. If x==y is compared then, the values carried by x and y are compared which is equal and therefore they return true. 

Equality operator: Compares by reference

Equals(): Compares by value 

13. What are the different ways in which a method can be Overloaded in C#?

A. Overloading means when a method has the same name but carries different values to use in a different context.
Only the main() method cannot be overloaded.

In order to overload methods in C#, 

=>Change the number of parameters in a method, or
=>Change the order of parameters in a method, or
=>Use different data types for parameters
In these ways, you can overload a method multiple times.
For ex.

public class Area {
   public double area(double x) {
       double area = x * x;
       return area;
   }
   public double area(double a, double b) {
       double area = a * b;
       return area;
   }
}

14.  What is Reflection in C#?

A. Reflection in C# extracts metadata from the datatypes during runtime. 

To add reflection in the .NET framework, simply use System.Refelction namespace in your program to retrieve the type which can be anything from:

Assembly
Module
Enum
MethodInfo
ConstructorInfo
MemberInfo
ParameterInfo
Type
FieldInfo
EventInfo
PropertyInfo

15. What is the difference between constant and readonly in C#?

A. A const keyword in C# is used to declare a constant field throughout the program. 
That means once a variable has been declared const, its value cannot be changed throughout the program. 

In C#, a constant is a number, string, null reference, or boolean values. 

For ex:

class IB {
 
   // Constant fields
   public const int xvar = 20;
   public const string str = "InterviewBit";
 
   // Main method
   static public void Main()
   {
 
       // Display the value of Constant fields
       Console.WriteLine("The value of xvar: {0}", xvar);
       Console.WriteLine("The value of str: {0}", str);
   }
}
Output:
The value of xvar is 20.
The value of string is Interview Bit

On the other hand, with readonly keyword, you can assign the variable 
only when it is declared or in a constructor of the same class in which it is declared. 

Ex:

public readonly int xvar1;
   public readonly int yvar2;
 
   // Values of the readonly 
   // variables are assigned
   // Using constructor
   public IB(int b, int c)
   {
 
       xvar1 = b;
       yvar2 = c;
       Console.WriteLine("The value of xvar1 {0}, "+
                       "and yvar2 {1}", xvar1, yvar2);
   }
 
   // Main method
   static public void Main()
   {
     IB obj1 = new IB(50, 60);
   }
}

Output:
The value of xvar1 is 50, and yvar2 is 60

Constants are static by default while readonly should have a value assigned when the constructor is declared. 
Constants can be declared within functions while readonly modifiers can be used with reference types. 

16. What is the difference between String and StringBuilder in C#?

A. The major difference between String and StringBuilder is that String objects are immutable while 
StringBuilder creates a mutable string of characters. StringBuilder will make the changes to the existing object rather than creating a new object.

StringBuilder simplifies the entire process of making changes to the existing string object. 
Since the String class is immutable, it is costlier to create a new object every time we need to make a change. 
So, the StringBuilder class comes into picture which can be evoked using the System.Text namespace.

In case, a string object will not change throughout the entire program, then use String class or else StringBuilder. 

For ex:

string s = string.Empty; 
for (i = 0; i < 1000; i++) 
  { 
    s += i.ToString() + " "; 
  }
Here, you’ll need to create 2001 objects out of which 2000 will be of no use.

The same can be applied using StringBuilder:

StringBuilder sb = new StringBuilder(); 
for (i = 0; i < 1000; i++) 
 { 
   sb.Append(i); sb.Append(' '); 
 }

By using StringBuilder here, you also de-stress the memory allocator.

17. What is the difference between Interface and Abstract Class in C#?

A. A class can implement any number of interfaces but a subclass can at most use only one abstract class.
An abstract class can have non-abstract methods (concrete methods) while in case of interface, all the methods have to be abstract.
An abstract class can declare or use any variables while an interface is not allowed to do so.
In an abstract class, all data members or functions are private by default while in an interface all are public, we can’t change them manually.
In an abstract class, we need to use abstract keywords to declare abstract methods, while in an interface we don’t need to use that.
An abstract class can’t be used for multiple inheritance while the interface can be used as multiple inheritance.
An abstract class use constructor while in an interface we don’t have any type of constructor.

18. What is the difference between the dispose and finalize methods in C#?

A. Finalize
Finalize is used to free unmanaged resources that are not in use, like files, database connections in the application domain and more.
These are resources held by an object before that object is destroyed.
In the Internal process, it is called by Garbage Collector and can’t be called manual by user code or any service.
Finalize belongs to System.Object class.
Implement it when you have unmanaged resources in your code, and make sure that these resources are freed when the Garbage collection happens.

Dispose
Dispose is also used to free unmanaged resources that are not in use like files, database connections in the Application domain at any time.
Dispose is explicitly called by manual user code.
If we need to use the dispose method, we must implement that class via IDisposable interface.
It belongs to IDisposable interface.
Implement this when you are writing a custom class that will be used by other users.

19. What are delegates in C# and the uses of delegates?

A. A Delegate is an abstraction of one or more function pointers (as existed in C++; the explanation about this is out of the scope of this article). 
The .NET has implemented the concept of function pointers in the form of delegates. 
With delegates, you can treat a function as data. 
Delegates allow functions to be passed as parameters, returned from a function as a value and stored in an array. 

Delegates have the following characteristics:
-Delegates are derived from the System.MulticastDelegate class.
-They have a signature and a return type. A function that is added to delegates must be compatible with this signature.
-Delegates can point to either static or instance methods.
-Once a delegate object has been created, it may dynamically invoke the methods it points to at runtime.
-Delegates can call methods synchronously and asynchronously.

The delegate contains a couple of useful fields. The first one holds a reference to an object, and the second holds a method pointer.
When you invoke the delegate, the instance method is called on the contained reference. 
However, if the object reference is null then the runtime understands this to mean that the method is a static method. 
Moreover, invoking a delegate syntactically is the exact same as calling a regular function. 
Therefore, delegates are perfect for implementing callbacks.
 
Why Do We Need Delegates?
 
Historically, the Windows API made frequent use of C-style function pointers to create callback functions. 
Using a callback, programmers were able to configure one function to report back to another function in the application. 
So the objective of using a callback is to handle button-clicking, menu-selection, and mouse-moving activities. 
But the problem with this traditional approach is that the callback functions were not type-safe. 
In the .NET framework, callbacks are still possible using delegates with a more efficient approach.

Delegates maintain three important pieces of information:
-The parameters of the method.
-The address of the method it calls.
-The return type of the method.

A delegate is a solution for situations in which you want to pass methods around to other methods. 
You are so accustomed to passing data to methods as parameters that the idea of passing methods as an argument instead of data might sound a little strange. 
However, there are cases in which you have a method that does something, for instance, invoking some other method.
You do not know at compile time what this second method is.
That information is available only at runtime, hence Delegates are the device to overcome such complications.

Delegates Sample Program

The delegate implementation can cause a great deal of confusion when encountered the first time. 
Thus, it is a great idea to get an understanding by creating this sample program as: 
using System;
namespace Delegates  
{  
    // Delegate Definition  
    public delegate int operation(int x, int y);  
         
    class Program  
    {  
        // Method that is passes as an Argument  
        // It has same signature as Delegates   
        static int Addition(int a, int b)  
        {  
            return a + b;  
        }  
  
        static void Main(string[] args)  
        {  
            // Delegate instantiation  
            operation obj = new operation(Program.Addition);  
   
            // output  
            Console.WriteLine("Addition is={0}",obj(23,27));   
            Console.ReadLine();    
        }  
    }  
}  
Here, we are defining the delegate as a delegate type. 
The important point to remember is that the signature of the function reference by the delegate must match the delegate signature as:

// Delegate Definition  
public delegate int operation(int x, int y);  
Notice the format of the operation delegate type declaration; it specifies that the operation object can permit any method taking two integers and returning an integer.

When you want to insert the target methods to a given delegate object, simply pass in the name of the method to the delegate constructor as: 
// Delegate instantiation  
operation obj = new operation(Program.Addition);  

At this point, you are able to invoke the member pointed to using a direct function invocation as:
Console.WriteLine("Addition is={0}",obj(23,27));   
Finally, when the delegate is no longer required, set the delegate instance to null.

Recall that .NET delegates are type-safe. Therefore, if you attempt to pass a delegate a method that does not match the signature pattern,
the .NET will report a compile-time error.

20. What is IEnumerable<> in C#?

A. IEnumerable is the parent interface for all non-generic collections in System.Collections namespace 
like ArrayList, HastTable etc. that can be enumerated. 
For the generic version of this interface as 
IEnumerable<T> which a parent interface of all generic collections class in System.Collections.Generic namespace 
like List<> and more.

In System.Collections.Generic.IEnumerable<T> have only a single method which is GetEnumerator() that returns an IEnumerator. 
IEnumerator provides the power to iterate through the collection by exposing a Current property and Move Next and Reset methods
if we don’t have this interface as a parent so we can’t use iteration by foreach loop or can’t use that class object in our LINQ query.
 
21. What is the difference between late binding and early binding in C#?

A. Compile Time Polymorphism or Early Binding
 
In Compile time polymorphism or Early Binding, we will use multiple methods with the same name but different types of parameters, or maybe the number of parameters. 
Because of this, we can perform different-different tasks with the same method name in the same class which is also known as Method overloading.

Run Time Polymorphism or Late Binding
 
Run time polymorphism is also known as late binding. 
In Run Time Polymorphism or Late Binding, we can use the same method names with the same signatures, 
which means the same type or the same number of parameters, but not in the same class 
because the compiler doesn’t allow for that at compile time. 
Therefore, we can use that bind at run time in the derived class when a child class or derived class object will be instantiated. 
That’s why we call it Late Binding. 
We have to create my parent class functions as partial and in driver or child class as override functions with the override keyword.

class Class1{
public virtual string Testfunc()
{
  return "Hello";
}
}

class Class2 : Class1{
public override string Testfunc()
{
  return "Bye";
}
}

class Program{
static void Main(string [] args)
{
  Class2 obj = new Class2();
  obj.Testfunc();
  
}
}

22. What are the differences between IEnumerable and IQueryable?

A. IEnumerable
 
Is the parent interface for all non-generic collections in System.Collections namespace like ArrayList, HastTable, etc. that can be enumerated. 
The generic version of this interface is IEnumerable<T>, 
which a parent interface of all generic collections class in System.Collections.Generic namespace, like List<> and more. 

IQueryable
 
As per MSDN, the IQueryable interface is intended for implementation by query providers and belongs to System.Linq namespace. 
It is only supposed to be implemented by providers that also implement IQueryable<T>. 
If the provider does not also implement IQueryable<T>, the standard query operators cannot be used on the provider's data source.

-IEnumerable is great for working with in-memory collections, but 
IQueryable allows for a remote data source such as a database or web service.
-IEnumerable is the return type for LINQ to Object and LINQ to XML queries.
IQueryable is the return type of LINQ to SQL queries.
-IEnumerable doesn't support lazy loading, so it is not recommended for paging kind of scenarios.
IQueryable supports lazy loading and we can use paging kind of scenarios.

23. What happens if the inherited interfaces have conflicting method names?

A. We have to use the interface name before the method name to remove this method confiscation.

namespace ConsoleApplication1  
{  
    interface IShow  
    {  
        void Show();  
    }    
    interface IShow_Case  
    {  
        void Show();  
    }  
    class B : IShow, IShow_Case  
    {  
        public void IShow.Show()  
        {  
            Console.WriteLine("IShow Interface function");  
        }    
        public void IShow_Case.Show()  
        {  
            Console.WriteLine("IShow_Case Interface function");  
        }   
        static void Main(string[] args)  
  
        {  
            IShow I = new B();  
            I.Show();  // IShow Interface function
            IShow_Case I1 = new B();  
            I1.Show(); // IShow_Case Interface function
            Console.ReadKey(true);  
        }  
    }    
}  

Here you need to remove Public modifier from the methods, because it implement by using interface name to differentiate same method by their interface. 
We know interface by default Public so we need to remove Public modifier from the methods. 

24. What is the Constructor Chaining in C#?

A. Constructor chaining is a way to connect two or more classes in a relationship as Inheritance. 
In Constructor Chaining, every child class constructor is mapped to a parent class Constructor implicitly by base keyword, 
so when you create an instance of the child class, it will call the parent’s class Constructor. 
Without it, inheritance is not possible.

25. What’s the difference between the Array.CopyTo() and Array.Clone()?

A. The Array.Clone() method creates a shallow copy of an array. 
A shallow copy of an Array copies only the elements of the Array, whether they are reference types or value types, 
but it does not copy the objects that the references refer to.
The references in the new Array point to the same objects that the references in the original Array point to.

The CopyTo() static method of the Array class copies a section of an array to another array. 
The CopyTo method copies all the elements of an array to another one-dimension array.
The code listed in Listing 9 copies contents of an integer array to an array of object types.

26. What are Singleton Design Patterns and how to implement them in C#? 

A. What is a Singleton Design Pattern? 
1. Ensures a class has only one instance and provides a global point of access to it.
2. A Singleton is a class that only allows a single instance of itself to be created and usually gives simple access to that instance.
3. Most commonly, singletons don't allow any parameters to be specified when creating the instance 
since the second request of an instance with a different parameter could be problematic! 
(If the same instance should be accessed for all requests with the same parameter then the factory pattern is more appropriate.)
4. There are various ways to implement the Singleton Pattern in C#. The following are the common characteristics of a Singleton Pattern.
-A single constructor, that is private and parameterless.
-The class is sealed.
-A static variable that holds a reference to the single created instance, if any.
-A public static means of getting the reference to the single created instance, creating one if necessary.

Example of how to write code with Singleton:
namespace Singleton {  
    class Program {  
        static void Main(string[] args) {  
            Calculate.Instance.ValueOne = 10.5;  
            Calculate.Instance.ValueTwo = 5.5;  
            Console.WriteLine("Addition : " + Calculate.Instance.Addition());  
            Console.WriteLine("Subtraction : " + Calculate.Instance.Subtraction());  
            Console.WriteLine("Multiplication : " + Calculate.Instance.Multiplication());  
            Console.WriteLine("Division : " + Calculate.Instance.Division());  
            Console.WriteLine("\n----------------------\n");  
            Calculate.Instance.ValueTwo = 10.5;  
            Console.WriteLine("Addition : " + Calculate.Instance.Addition());  
            Console.WriteLine("Subtraction : " + Calculate.Instance.Subtraction());  
            Console.WriteLine("Multiplication : " + Calculate.Instance.Multiplication());  
            Console.WriteLine("Division : " + Calculate.Instance.Division());  
            Console.ReadLine();  
        }  
    }  
    public sealed class Calculate {  
        private Calculate() {}  
        private static Calculate instance = null;  
        public static Calculate Instance {  
            get {  
                if (instance == null) {  
                    instance = new Calculate();  
                }  
                return instance;  
            }  
        }  
        public double ValueOne {  
            get;  
            set;  
        }  
        public double ValueTwo {  
            get;  
            set;  
        }  
        public double Addition() {  
            return ValueOne + ValueTwo;  
        }  
        public double Subtraction() {  
            return ValueOne - ValueTwo;  
        }  
        public double Multiplication() {  
            return ValueOne * ValueTwo;  
        }  
        public double Division() {  
            return ValueOne / ValueTwo;  
        }  
    }  
}  

27. Difference between Throw Exception and Throw Clause.

A. The basic difference is that the Throw exception overwrites the stack trace. 
This makes it hard to find the original code line number that has thrown the exception.

Throw basically retains the stack information and adds to the stack information in the exception that it is thrown.

using System;  
using System.Collections.Generic;  
using System.Linq;  
using System.Text;  
namespace TestingThrowExceptions {  
    class Program {  
        public void ExceptionMethod() {  
            throw new Exception("Original Exception occurred in ExceptionMethod");  
        }  
        static void Main(string[] args) {  
            Program p = new Program();  
            try {  
                p.ExceptionMethod();  
            } catch (Exception ex) {  
                throw ex;  
            }  
        }  
    }  
}  
It returns an exception and look at the stack trace.

28. What are Indexers in C#?

A. C# introduces a new concept known as Indexers which are used for treating an object as an array. 
The indexers are usually known as smart arrays in C#. They are not an essential part of object-oriented programming.
 
Defining an indexer allows you to create classes that act as virtual arrays. 
Instances of that class can be accessed using the [] array access operator.

Creating an Indexer 
< modifier > < return type > this[argument list] {    
    get {    
        // your get block code    
    }    
    set {    
        // your set block code    
    }    
}    
In the above code,
 
<modifier>
 
can be private, public, protected or internal.
 
<return type>
 
can be any valid C# types.

29. SOLID principles

A. SOLID principles are the design principles that enable us to manage most of the software design problems.
S: Single Responsibility Principle (SRP)
O: Open closed Principle (OCP)
L: Liskov substitution Principle (LSP)
I: Interface Segregation Principle (ISP)
D: Dependency Inversion Principle (DIP)

S: Single Responsibility Principle (SRP)
This means that every class, or similar structure, in your code should have only one job to do.
Everything in that class should be related to a single purpose. 
Our class should not be like a Swiss knife wherein if one of them needs to be changed then the entire tool needs to be altered. 
It does not mean that your classes should only contain one method or property. 
There may be many members as long as they relate to single responsibility.

The Single Responsibility Principle gives us a good way of identifying classes at the design phase of an application and it makes you think of all the ways a class can change. 
A good separation of responsibilities is done only when we have the full picture of how the application should work.

public class UserService  
{  
   public void Register(string email, string password)  
   {  
      if (!ValidateEmail(email))  
         throw new ValidationException("Email is not an email");  
         var user = new User(email, password);  
  
         SendEmail(new MailMessage("mysite@nowhere.com", email) { Subject="HEllo foo" });  
   }
   public virtual bool ValidateEmail(string email)  
   {  
     return email.Contains("@");  
   }  
   public bool SendEmail(MailMessage message)  
   {  
     _smtpClient.Send(message);  
   }  
}   

It looks fine, but it is not following SRP.
The SendEmail and ValidateEmail methods have nothing to do within the UserService class. Let's refract it.

public class UserService  
{  
   EmailService _emailService;  
   DbContext _dbContext;  
   public UserService(EmailService aEmailService, DbContext aDbContext)  
   {  
      _emailService = aEmailService;  
      _dbContext = aDbContext;  
   }  
   public void Register(string email, string password)  
   {  
      if (!_emailService.ValidateEmail(email))  
         throw new ValidationException("Email is not an email");  
         var user = new User(email, password);  
         _dbContext.Save(user);  
         emailService.SendEmail(new MailMessage("myname@mydomain.com", email) {Subject="Hi. How are you!"});  
  
      }  
   }  
   public class EmailService  
   {  
      SmtpClient _smtpClient;  
   public EmailService(SmtpClient aSmtpClient)  
   {  
      _smtpClient = aSmtpClient;  
   }  
   public bool virtual ValidateEmail(string email)  
   {  
      return email.Contains("@");  
   }  
   public bool SendEmail(MailMessage message)  
   {  
      _smtpClient.Send(message);  
   }  
}   

O: Open/Closed Principle
The Open/closed Principle says "A software module/class is open for extension and closed for modification".
Here "Open for extension" means, we need to design our module/class in such a way that the new functionality can be added only when new requirements are generated.
"Closed for modification" means we have already developed a class and it has gone through unit testing. We should then not alter it until we find bugs. 
As it says, a class should be open for extensions, we can use inheritance to do this. Okay, let's dive into an example.

Suppose we have a Rectangle class with the properties Height and Width.
public class Rectangle{  
   public double Height {get;set;}  
   public double Wight {get;set; }  
}  

Our app needs the ability to calculate the total area of a collection of Rectangles. 
Since we already learned the Single Responsibility Principle (SRP), we don't need to put the total area calculation code inside the rectangle. 
So here I created another class for area calculation.
public class AreaCalculator {  
   public double TotalArea(Rectangle[] arrRectangles)  
   {  
      double area;  
      foreach(var objRectangle in arrRectangles)  
      {  
         area += objRectangle.Height * objRectangle.Width;  
      }  
      return area;  
   }  
}  
 
can we extend our app so that it could calculate the area of not only Rectangles but also the area of Circles as well? 
Now we have an issue with the area calculation issue because the way to do circle area calculation is different.
We can change the TotalArea method a bit so that it can accept an array of objects as an argument. 
We check the object type in the loop and do area calculation based on the object type.
public class Rectangle{  
   public double Height {get;set;}  
   public double Wight {get;set; }  
}  
public class Circle{  
   public double Radius {get;set;}  
}  
public class AreaCalculator  
{  
   public double TotalArea(object[] arrObjects)  
   {  
      double area = 0;  
      Rectangle objRectangle;  
      Circle objCircle;  
      foreach(var obj in arrObjects)  
      {  
         if(obj is Rectangle)  
         {    
            area += obj.Height * obj.Width;  
         }  
         else  
         {  
            objCircle = (Circle)obj;  
            area += objCircle.Radius * objCircle.Radius * Math.PI;  
         }  
      }  
      return area;  
   }  
}  

L: Liskov Substitution Principle
The Liskov Substitution Principle (LSP) states that 
"you should be able to use any derived class instead of a parent class and have it behave in the same manner without modification".
It ensures that a derived class does not affect the behavior of the parent class, in other words,, that a derived class must be substitutable for its base class.

This principle is just an extension of the Open Closed Principle and 
it means that we must ensure that new derived classes extend the base classes without changing their behavior.

