Char.IsNumber(Char)  //method to check whether the specified Unicode character matches number or not

using System;
class GFG {
 
    // Main Method
    static public void Main()
    {
 
        // Declaration of data type
        bool result;
 
        // checking if 5 is a
        // number or not
        char ch1 = '5';
        result = Char.IsNumber(ch1);
        Console.WriteLine(result);    //True
 
        // checking if 'c' is a
        // number or not
        char ch2 = 'c';
        result = Char.IsNumber(ch2);
        Console.WriteLine(result);    //False
    }
}

Char.IsNumber(String, Int32) //method is used to check whether the specified string at specified position matches with any number or not.
 
using System;
class GFG {
 
    // Main Method
    static public void Main()
    {
 
        // Declaration of data type
        bool result;
 
        // checking for number in a
        // string at a desired position
        string str1 = "GeeksforGeeks";
        result = Char.IsNumber(str1, 2);
        Console.WriteLine(result);        //False
 
        // checking for number in a
        // string at a desired position
        string str2 = "geeks5forgeeks";
        result = Char.IsNumber(str2, 5);  //True
        Console.WriteLine(result);
    }
}

C# Serialization & Deserialization
//Serialization is a concept in which C# class objects are written or serialized to files.
//example C# class Tutorial having 2 properties ID and Tutorial name
//Serializing can be used to directly write the data properties of the Tutorial class to a file.
//Deserialization is used to read the data from the file and construct the Tutorial object again.
using System;
using System.IO;
using System.Linq;
using System.Runtime.Serialization;
using System.Runtime.Serialization.Formatters.Binary;
using System.Text;
using System.Threading.Tasks;
namespace DemoApplication
{
  [Serializable]
  class Tutorial
  {
  public int ID;
  public String Name;
   static void Main(string[] args)
   {
    Tutorial obj = new Tutorial();
    obj.ID = 1;
    obj.Name = ".Net";
 
    //create the file stream
    IFormatter formatter = new BinaryFormatter();
    Stream stream = new FileStream(@"E:\ExampleNew.txt",FileMode.Create,FileAccess.Write);

    //serialize the object
    formatter.Serialize(stream, obj);
    stream.Close();

    //create the file stream
    stream = new FileStream(@"E:\ExampleNew.txt",FileMode.Open,FileAccess.Read);
    
    //deserialize the object
    Tutorial objnew = (Tutorial)formatter.Deserialize(stream);

    //write data to the console
    Console.WriteLine(objnew.ID);
    Console.WriteLine(objnew.Name);

    Console.ReadKey();
  }
 }
}

# Questions
==================
1. What are the differences between ref and out keywords?

A. C# ref keywords pass arguments by reference and not value. To use the ‘ref’ keyword, you need to explicitly mention ‘ref’. 

void Method(ref int refArgument)
{
   refArgument = refArgument + 10;
}
int number = 1;
Method(ref number);
Console.WriteLine(number);
// Output: 11

C# out keywords pass arguments within methods and functions. 
‘out’ keyword is used to pass arguments in a method as a reference to return multiple values. 
Although it is the same as the ref keyword, the ref keyword needs to be initialised before it is passed. 
Here, The out and ref keywords are useful when we want to return a value in the same variables that are passed as an argument. 

public static string GetNextFeature(ref int id)  
{  
   string returnText = "Next-" + id.ToString();  
   id += 1;  
   return returnText;  
}  
public static string GetNextFeature(out int id)  
{  
   id = 1;  
   string returnText = "Next-" + id.ToString();  
   return returnText;  
}   

2. What are extension methods in C#?

A. Extension methods help to add new methods to the existing ones. 
The methods that are added are static. 
At times, when you want to add methods to an existing class but don’t perceive the right to modify that class or don’t hold the rights, 
you can create a new static class containing the new methods.
Once the extended methods are declared, bind this class with the existing one and see the methods will be added to the existing one.

// C# program to illustrate the concept
// of the extension methods
using System;
 
namespace ExtensionMethod {
static class NewMethodClass {
 
   // Method 4
   public static void M4(this Scaler s)
   {
       Console.WriteLine("Method Name: M4");
   }
 
   // Method 5
   public static void M5(this Scaler s, string str)
   {
       Console.WriteLine(str);
   }
}
 
// Now we create a new class in which
// Scaler class access all the five methods
public class IB {
 
   // Main Method
   public static void Main(string[] args)
   {
       Scaler s = new Scaler();
       s.M1();
       s.M2();
       s.M3();
       s.M4();
       s.M5("Method Name: M5");
   }
}
}
Output:

Method Name: M1

Method Name: M2

Method Name: M3

Method Name: M4

Method Name: M5

3. What are Generics in C#?

A. In C# collections, defining any kind of object is termed okay which compromises C#’s basic rule of type-safety. 
Therefore, generics were included to type-safe the code by allowing re-use of the data processing algorithms. 
Generics in C# mean not linked to any specific data type. Generics reduce the load of using boxing, unboxing, and typecasting objects.
Generics are always defined inside angular brackets <>. To create a generic class, this syntax is used:

GenericList<float> list1 = new GenericList<float>();
GenericList<Features> list2 = new GenericList<Features>();
GenericList<Struct> list3 = new GenericList<Struct>();

Here, GenericList<float> is a generic class. 
In each of these instances of GenericList<T>, every occurrence of T in the class is substituted at run time with the type argument. 
By substituting the T, we have created three different type-safe using the same class. 

4. What is the difference between an Array and ArrayList in C#?

A. An array is a collection of similar variables clubbed together under one common name. 
While ArrayList is a collection of objects that can be indexed individually.
With ArrayList you can access a number of features like dynamic memory allocation, adding, searching, and sorting items in the ArrayList. 

=>When declaring an array the size of the items is fixed therefore, the memory allocation is fixed. But with ArrayList, it can be increased or decreased dynamically.
=>Array belongs to system.array namespace while ArrayList belongs to the system.collection namespace.
=>All items in an array are of the same datatype while all the items in an ArrayList can be of the same or different data types.
=>While arrays cannot accept null, ArrayList can accept null values.

For ex.:

// C# program to illustrate the ArrayList
using System;
using System.Collections;
 
class IB {
 
   // Main Method
   public static void Main(string[] args)
   {
 
       // Create a list of strings
       ArrayList al = new ArrayList();
       al.Add("Bruno");
       al.Add("Husky");
       al.Add(10);
       al.Add(10.10);
 
       // Iterate list element using foreach loop
       foreach(var names in al)
       {
           Console.WriteLine(names);
       }
   }
}

5. What is inheritance? Does C# support multiple inheritance?

A. Inheritance means acquiring some of the properties from a master class.     A     B
                                                                                \   /
                                                                                  C
Here, class C can inherit properties from Class A and Class B. But, C# doesn’t support multiple inheritances. 
Instead, you can use interfaces to inherit the properties using the class name in the signature.

// C# program to illustrate
// multiple class inheritance
using System;
using System.Collections;

// Parent class 1
class Scaler {

  // Providing the implementation
  // of features() method
  public void features()
  {

      // Creating ArrayList
      ArrayList My_features= new ArrayList();

      // Adding elements in the
      // My_features ArrayList
      My_features.Add("Abstraction");
      My_features.Add("Encapsulation");
      My_features.Add("Inheritance");

      Console.WriteLine("Features provided by OOPS:");
      foreach(var elements in My_features)
      {
          Console.WriteLine(elements);
      }
  }
}

// Parent class 2
class Scaler2 :Scaler{

  // Providing the implementation
  // of courses() method
  public void languages()
  {

      // Creating ArrayList
      ArrayList My_features = new ArrayList();

      // Adding elements in the
      // My_features ArrayList
      My_features.Add("C++");
      My_features.Add("C#");
      My_features.Add("JScript");
     

      Console.WriteLine("\nLanguages that use OOPS concepts:");
      foreach(var elements in My_features)
      {
          Console.WriteLine(elements);
      }
  }
}

// Child class
class ScalertoScaler : Scaler2 {
}

public class Scaler1 {

  // Main method
  static public void Main()
  {

      // Creating object of ScalertoScaler class
      ScalertoScaler obj = new ScalertoScaler();
      obj.features();
      obj.languages();
  }
}

6. What is Boxing and Unboxing in C#?

A. Boxing: Boxing converts value type (int, char, etc.) to reference type (object) which is an implicit conversion process using object value. 
int num = 23; // 23 will assigned to num
Object Obj = num; // Boxing

Unboxing: Unboxing converts reference type (object) to value type (int, char, etc.) using an explicit conversion process. 
int num = 23;         // value type is int and assigned value 23
Object Obj = num;    // Boxing
int i = (int)Obj;    // Unboxing

7. What are Properties in C#?

A. Properties in C# are public members of a class where they provide the ability to access private members of a class. 
The basic principle of encapsulation lets you hide some sensitive properties from the users by making the variables private. 
The private members are not accessible otherwise in a class. 
Therefore, by using properties in C# you can easily access the private members and set their values. 

The values can be easily assigned using get and set methods, also known as accessors.
While the get method extracts the value, the set method assigns the value to the variables.

8. What are partial classes in C#?

A. Partial classes implement the functionality of a single class into multiple files. 
These multiple files are combined into one during compile time. The partial class can be created using the partial keyword. 

public partial Clas_name  
{
       // code
}
You can easily split the functionalities of methods, interfaces, or structures into multiple files. 
You can even add nested partial classes. 

9.  What is the difference between late binding and early binding in C#?

A. Late binding and early binding are examples of one of the primary concepts of OOPS: Polymorphism. 

For ex: one function calculateBill() will calculate bills of premium customers, basic customers, and semi-premium customers based on their policies differently.
The calculation for all the customer objects is done differently using the same function which is called polymorphism. 

When an object is assigned to an object variable in C#, the .NET framework performs the binding. 

When the binding function happens at compile-time, it is called early binding. 
It investigates and checks the methods and properties of the static objects. 
With early binding, the number of run-time errors decreases substantially and it executes pretty quickly. 

But when the binding happens at runtime, it is called late binding. 
Late binding happens when the objects are dynamic (decided based on the data they hold) at run-time. 
It is slower as it looks through during run-time.

10. Arrays in C#

A. A few pointers for arrays in C#:

-The memory allocation is DYNAMIC.
-Arrays in C# are treated as objects.
-The length of the array is easy to find by detecting the number of members in the array.
-The members in the array are ordered and begin with the index value=0.
-The array types are reference types derived from the base array type.
-Syntax: < Data Type > [ ] < Name_Array >

11. What are Indexers in C#?

A. Indexers are called smart arrays that allow access to a member variable. 
Indexers allow member variables using the features of an array. They are created using the Indexer keyword. 
Indexers are not static members. 

For ex. Here the indexer is defined the same way.

<return type> this[<parameter type> index]
{
   get{
       // return the value from the specified index of an internal collection
   }
   set{
       // set values at the specified index in an internal collection
   }
}

12. Difference between the Equality Operator (==) and Equals() Method in C#?

A. Although both are used to compare two objects by value, still they both are used differently. 

For ex.:

int x = 10;
int y = 10;
Console.WriteLine( x == y);
Console.WriteLine(x.Equals(y));
Output:
True
True

Equality operator (==) is a reference type which means that if equality operator is used, it will return true only if both the references point to the same object.  

Equals() method: Equals method is used to compare the values carried by the objects. 
int x=10, int y=10. If x==y is compared then, the values carried by x and y are compared which is equal and therefore they return true. 

Equality operator: Compares by reference

Equals(): Compares by value 

13. What are the different ways in which a method can be Overloaded in C#?

A. Overloading means when a method has the same name but carries different values to use in a different context.
Only the main() method cannot be overloaded.

In order to overload methods in C#, 

=>Change the number of parameters in a method, or
=>Change the order of parameters in a method, or
=>Use different data types for parameters
In these ways, you can overload a method multiple times.
For ex.

public class Area {
   public double area(double x) {
       double area = x * x;
       return area;
   }
   public double area(double a, double b) {
       double area = a * b;
       return area;
   }
}

14.  What is Reflection in C#?

A. Reflection in C# extracts metadata from the datatypes during runtime. 

To add reflection in the .NET framework, simply use System.Refelction namespace in your program to retrieve the type which can be anything from:

Assembly
Module
Enum
MethodInfo
ConstructorInfo
MemberInfo
ParameterInfo
Type
FieldInfo
EventInfo
PropertyInfo

15. What is the difference between constant and readonly in C#?

A. A const keyword in C# is used to declare a constant field throughout the program. 
That means once a variable has been declared const, its value cannot be changed throughout the program. 

In C#, a constant is a number, string, null reference, or boolean values. 

For ex:

class IB {
 
   // Constant fields
   public const int xvar = 20;
   public const string str = "InterviewBit";
 
   // Main method
   static public void Main()
   {
 
       // Display the value of Constant fields
       Console.WriteLine("The value of xvar: {0}", xvar);
       Console.WriteLine("The value of str: {0}", str);
   }
}
Output:
The value of xvar is 20.
The value of string is Interview Bit

On the other hand, with readonly keyword, you can assign the variable 
only when it is declared or in a constructor of the same class in which it is declared. 

Ex:

public readonly int xvar1;
   public readonly int yvar2;
 
   // Values of the readonly 
   // variables are assigned
   // Using constructor
   public IB(int b, int c)
   {
 
       xvar1 = b;
       yvar2 = c;
       Console.WriteLine("The value of xvar1 {0}, "+
                       "and yvar2 {1}", xvar1, yvar2);
   }
 
   // Main method
   static public void Main()
   {
     IB obj1 = new IB(50, 60);
   }
}

Output:
The value of xvar1 is 50, and yvar2 is 60

Constants are static by default while readonly should have a value assigned when the constructor is declared. 
Constants can be declared within functions while readonly modifiers can be used with reference types. 

16. What is the difference between String and StringBuilder in C#?

A. The major difference between String and StringBuilder is that String objects are immutable while 
StringBuilder creates a mutable string of characters. StringBuilder will make the changes to the existing object rather than creating a new object.

StringBuilder simplifies the entire process of making changes to the existing string object. 
Since the String class is immutable, it is costlier to create a new object every time we need to make a change. 
So, the StringBuilder class comes into picture which can be evoked using the System.Text namespace.

In case, a string object will not change throughout the entire program, then use String class or else StringBuilder. 

For ex:

string s = string.Empty; 
for (i = 0; i < 1000; i++) 
  { 
    s += i.ToString() + " "; 
  }
Here, you’ll need to create 2001 objects out of which 2000 will be of no use.

The same can be applied using StringBuilder:

StringBuilder sb = new StringBuilder(); 
for (i = 0; i < 1000; i++) 
 { 
   sb.Append(i); sb.Append(' '); 
 }

By using StringBuilder here, you also de-stress the memory allocator.

17. What is the difference between Interface and Abstract Class in C#?

A. A class can implement any number of interfaces but a subclass can at most use only one abstract class.
An abstract class can have non-abstract methods (concrete methods) while in case of interface, all the methods have to be abstract.
An abstract class can declare or use any variables while an interface is not allowed to do so.
In an abstract class, all data members or functions are private by default while in an interface all are public, we can’t change them manually.
In an abstract class, we need to use abstract keywords to declare abstract methods, while in an interface we don’t need to use that.
An abstract class can’t be used for multiple inheritance while the interface can be used as multiple inheritance.
An abstract class use constructor while in an interface we don’t have any type of constructor.

18. 
